<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Radio Guaka - An Internet Radio player. Stream your favorite stations including SomaFM, FIP, Radio Paradise, and more.">
  
  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://radio.guaka.org/">
  <meta property="og:title" content="Radio Guaka">
  <meta property="og:description" content="An Internet Radio player. Stream your favorite stations including SomaFM, FIP, Radio Paradise, and more.">
  <meta property="og:image" content="https://radio.guaka.org/og-image.png">
  
  <!-- Twitter -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:url" content="https://radio.guaka.org/">
  <meta name="twitter:title" content="Radio Guaka">
  <meta name="twitter:description" content="An Internet Radio player. Stream your favorite stations including SomaFM, FIP, Radio Paradise, and more.">
  <meta name="twitter:image" content="https://radio.guaka.org/og-image.png">
  
  <title>Radio Guaka</title>
  <link rel="icon" type="image/png" href="favicon.ico">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <style>
    /* Hide page until fonts load to prevent system font probing */
    html { visibility: hidden; opacity: 0; }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=block" rel="stylesheet">
  <script>
    // Block rendering until fonts are loaded - must run immediately
    (function() {
      function showPage() {
        document.documentElement.style.visibility = 'visible';
        document.documentElement.style.opacity = '1';
      }
      
      if ('fonts' in document) {
        // Wait for fonts to be ready
        if (document.fonts.ready) {
          document.fonts.ready.then(function() {
            // Ensure fonts are actually loaded
            Promise.all([
              document.fonts.load('400 1em "Share Tech Mono"'),
              document.fonts.load('700 1em "Orbitron"'),
              document.fonts.load('400 1em "Orbitron"'),
              document.fonts.load('900 1em "Orbitron"')
            ]).then(showPage).catch(function() {
              setTimeout(showPage, 300);
            });
          }).catch(function() {
            setTimeout(showPage, 300);
          });
        } else {
          Promise.all([
            document.fonts.load('400 1em "Share Tech Mono"'),
            document.fonts.load('700 1em "Orbitron"'),
            document.fonts.load('400 1em "Orbitron"'),
            document.fonts.load('900 1em "Orbitron"')
          ]).then(showPage).catch(function() {
            setTimeout(showPage, 300);
          });
        }
      } else {
        setTimeout(showPage, 100);
      }
    })();
  </script>
  <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
  <style>
    
    html {
      font-size: 16px;
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: auto;
      -webkit-overflow-scrolling: touch;
    }
    
    /* Scan lines overlay for retro-futuristic effect - static to prevent flickering */
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: repeating-linear-gradient(
        0deg,
        rgba(0, 255, 255, 0.02) 0px,
        rgba(0, 255, 255, 0.02) 1px,
        transparent 1px,
        transparent 2px
      );
      pointer-events: none;
      z-index: 1;
    }
    
    /* Glitch effect overlay - static to prevent flickering */
    body::after {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        linear-gradient(90deg, transparent 50%, rgba(0, 255, 255, 0.01) 50%),
        linear-gradient(0deg, transparent 50%, rgba(255, 0, 255, 0.01) 50%);
      background-size: 2px 2px;
      pointer-events: none;
      z-index: 1;
      opacity: 0.2;
    }
    
    html, body {
      background: 
        radial-gradient(circle at 20% 50%, rgba(0, 255, 255, 0.05) 0%, transparent 50%),
        radial-gradient(circle at 80% 80%, rgba(255, 0, 255, 0.05) 0%, transparent 50%),
        linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #0a0a0a 100%);
      background-attachment: fixed;
      background-color: #0a0a0a;
      color: #e0e0e0;
      margin: 0;
      padding: 0;
      font-family: 'Share Tech Mono', 'Courier New', 'Courier', 'Lucida Console', 'Monaco', 'Consolas';
      font-size: 1rem;
      line-height: 1.6;
      min-height: 100vh;
      overflow-x: hidden;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      position: relative;
    }

    .container {
      width: 100%;
      max-width: 100%;
      margin: 0;
      padding: 0 clamp(8px, 1.5vw, 15px);
      box-sizing: border-box;
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: visible;
      position: relative;
      z-index: 10;
    }

    body {
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      overflow-x: hidden;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      position: relative;
      width: 100%;
    }

    header {
      padding: 0;
      margin: 0;
      border-bottom: 2px solid rgba(0, 255, 255, 0.4);
      background: 
        linear-gradient(180deg, rgba(20, 20, 30, 0.95) 0%, rgba(10, 10, 20, 0.98) 100%),
        repeating-linear-gradient(
          90deg,
          transparent,
          transparent 2px,
          rgba(0, 255, 255, 0.05) 2px,
          rgba(0, 255, 255, 0.05) 4px
        );
      backdrop-filter: blur(10px);
      box-shadow: 
        0 4px 20px rgba(0, 0, 0, 0.8),
        inset 0 1px 0 rgba(0, 255, 255, 0.3),
        0 0 40px rgba(0, 255, 255, 0.2),
        0 0 60px rgba(0, 255, 255, 0.1);
      position: relative;
      z-index: 10;
    }
    
    header::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, 
        transparent 0%,
        rgba(0, 255, 255, 1) 20%,
        rgba(255, 0, 255, 1) 50%,
        rgba(0, 255, 255, 1) 80%,
        transparent 100%
      );
      box-shadow: 
        0 0 10px rgba(0, 255, 255, 0.8),
        0 0 20px rgba(0, 255, 255, 0.5),
        0 0 30px rgba(255, 0, 255, 0.4);
      z-index: 1;
    }

    header .container {
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: clamp(8px, 2vw, 12px);
      justify-content: space-between;
      padding: clamp(4px, 0.8vh, 8px) clamp(8px, 1.5vw, 15px) 0 clamp(8px, 1.5vw, 15px);
      flex-wrap: wrap;
    }
    
    header .volume-control {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
      margin-left: auto;
      padding: 8px 12px;
      background: 
        linear-gradient(135deg, rgba(20, 20, 40, 0.8) 0%, rgba(10, 10, 30, 0.9) 100%);
      border: 1px solid rgba(0, 255, 255, 0.3);
      border-radius: 6px;
      box-shadow: 
        inset 0 1px 2px rgba(0, 255, 255, 0.2),
        0 0 15px rgba(0, 255, 255, 0.3),
        0 0 25px rgba(0, 255, 255, 0.2);
    }
    
    header .volume-control span {
      font-size: clamp(14px, 2.5vw, 18px);
      filter: drop-shadow(0 0 8px rgba(0, 255, 255, 0.9)) drop-shadow(0 0 16px rgba(0, 255, 255, 0.5));
    }
    
    header .volume-control input[type="range"] {
      -webkit-appearance: slider-vertical;
      appearance: slider-vertical;
      writing-mode: bt-lr;
      width: 80px;
      height: 6px;
      transform: rotate(-90deg);
      transform-origin: center;
      margin: 25px 0;
      padding: 0;
      cursor: pointer;
      background: 
        linear-gradient(90deg, 
          rgba(0, 0, 0, 0.8) 0%,
          rgba(0, 255, 255, 0.2) 50%,
          rgba(0, 0, 0, 0.8) 100%
        );
      border-radius: 3px;
      outline: none;
      border: 1px solid rgba(0, 255, 255, 0.3);
      box-shadow: 
        inset 0 1px 3px rgba(0, 0, 0, 0.5),
        0 0 8px rgba(0, 255, 255, 0.2);
    }
    
    header .volume-control input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      background: 
        radial-gradient(circle, #00ffff 0%, #0080ff 100%);
      border: 2px solid rgba(0, 255, 255, 0.8);
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 
        0 0 15px rgba(0, 255, 255, 1),
        0 0 30px rgba(0, 255, 255, 0.7),
        0 0 45px rgba(0, 255, 255, 0.4),
        inset 0 1px 2px rgba(255, 255, 255, 0.4);
      transition: all 0.2s ease;
    }
    
    header .volume-control input[type="range"]::-webkit-slider-thumb:hover {
      box-shadow: 
        0 0 20px rgba(0, 255, 255, 1),
        0 0 40px rgba(0, 255, 255, 0.8),
        0 0 60px rgba(0, 255, 255, 0.5),
        inset 0 1px 2px rgba(255, 255, 255, 0.5);
      transform: scale(1.1);
    }
    
    header .volume-control input[type="range"]::-moz-range-thumb {
      width: 16px;
      height: 16px;
      background: 
        radial-gradient(circle, #00ffff 0%, #0080ff 100%);
      border: 2px solid rgba(0, 255, 255, 0.8);
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 
        0 0 15px rgba(0, 255, 255, 1),
        0 0 30px rgba(0, 255, 255, 0.7),
        0 0 45px rgba(0, 255, 255, 0.4);
    }

    header h1 {
      margin: 0;
      display: flex;
      align-items: center;
      gap: clamp(8px, 2vw, 12px);
      font-size: clamp(18px, 4vw, 24px);
      font-weight: 700;
      font-family: 'Orbitron', 'Share Tech Mono', 'Courier New', 'Courier', 'Lucida Console', 'Monaco', 'Consolas';
      color: #00ffff;
      text-shadow: 
        0 0 10px rgba(0, 255, 255, 1),
        0 0 20px rgba(0, 255, 255, 0.8),
        0 0 30px rgba(0, 255, 255, 0.6),
        0 0 40px rgba(0, 255, 255, 0.4),
        2px 2px 4px rgba(0, 0, 0, 0.8);
      letter-spacing: 2px;
      text-transform: uppercase;
      position: relative;
      line-height: 1.2;
    }

    header h1 .logo-icon {
      font-size: clamp(28px, 7vw, 42px);
      line-height: 1;
      display: inline-flex;
      align-items: center;
      filter: drop-shadow(0 0 10px rgba(255, 200, 0, 1)) drop-shadow(0 0 20px rgba(255, 200, 0, 0.6)) drop-shadow(0 0 30px rgba(255, 200, 0, 0.3));
      animation: radio-pulse 3s ease-in-out infinite;
    }
    
    @keyframes radio-pulse {
      0%, 100% { 
        transform: scale(1); 
        filter: drop-shadow(0 0 10px rgba(255, 200, 0, 1)) drop-shadow(0 0 20px rgba(255, 200, 0, 0.6)) drop-shadow(0 0 30px rgba(255, 200, 0, 0.3));
      }
      50% { 
        transform: scale(1.05); 
        filter: drop-shadow(0 0 15px rgba(255, 200, 0, 1)) drop-shadow(0 0 30px rgba(255, 200, 0, 0.8)) drop-shadow(0 0 45px rgba(255, 200, 0, 0.5));
      }
    }

    header h1 strike {
      color: rgba(255, 0, 255, 0.6);
      text-decoration: line-through;
      text-shadow: 0 0 5px rgba(255, 0, 255, 0.5);
    }

    header audio {
      display: none;
    }
    
    header input[type="range"]:not(.volume-control input) {
      -webkit-appearance: none;
      appearance: none;
      height: 6px;
      background: 
        linear-gradient(90deg, 
          rgba(0, 0, 0, 0.8) 0%,
          rgba(0, 255, 255, 0.2) 50%,
          rgba(0, 0, 0, 0.8) 100%
        );
      border-radius: 3px;
      outline: none;
      border: 1px solid rgba(0, 255, 255, 0.3);
      box-shadow: 
        inset 0 1px 3px rgba(0, 0, 0, 0.5),
        0 0 8px rgba(0, 255, 255, 0.2);
    }
    
    header input[type="range"]:not(.volume-control input)::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 14px;
      height: 14px;
      background: 
        radial-gradient(circle, #00ffff 0%, #0080ff 100%);
      border: 2px solid rgba(0, 255, 255, 0.8);
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 
        0 0 8px rgba(0, 255, 255, 0.8),
        0 0 16px rgba(0, 255, 255, 0.4);
    }
    
    header input[type="range"]:not(.volume-control input)::-moz-range-thumb {
      width: 14px;
      height: 14px;
      background: 
        radial-gradient(circle, #00ffff 0%, #0080ff 100%);
      border: 2px solid rgba(0, 255, 255, 0.8);
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 
        0 0 8px rgba(0, 255, 255, 0.8),
        0 0 16px rgba(0, 255, 255, 0.4);
    }

    header > div > div:not(.volume-control) {
      display: flex;
      align-items: center;
      gap: clamp(6px, 1.5vw, 10px);
      font-size: clamp(11px, 2vw, 13px);
      color: #aaa;
      flex-wrap: wrap;
    }
    
    .header-controls-wrapper {
      display: flex;
      align-items: center;
      gap: clamp(8px, 2vw, 12px);
      flex-wrap: wrap;
      width: 100%;
    }
    
    .header-controls-audio {
      flex: 1;
      min-width: 0;
      width: 100%;
    }
    
    .header-channel-info {
      display: flex;
      flex-direction: column;
      gap: 4px;
      width: 100%;
    }


    article {
      padding: clamp(12px, 2.5vh, 24px) 0 clamp(50px, 7vh, 60px) 0;
      flex: 1;
      overflow-y: visible;
      overflow-x: hidden;
      min-height: 0;
      background: 
        radial-gradient(circle at 50% 0%, rgba(0, 255, 255, 0.02) 0%, transparent 50%);
      position: relative;
      z-index: 10;
      -webkit-overflow-scrolling: touch;
    }
    
    article .container {
      height: auto;
      overflow: visible;
      min-height: 0;
    }

    #channels {
      display: flex;
      flex-wrap: wrap;
      gap: clamp(4px, 1.2vw, 8px);
      margin-bottom: clamp(10px, 2vh, 20px);
    }

    /* Button styles - oldschool radio + cyberpunk */
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: clamp(3px, 0.6vh, 4px) clamp(6px, 1.2vw, 10px);
      font-size: clamp(11px, 2vw, 13px);
      font-weight: 400;
      font-family: 'Share Tech Mono', 'Courier New', 'Courier', 'Lucida Console', 'Monaco', 'Consolas';
      line-height: 1.4;
      text-align: center;
      white-space: nowrap;
      cursor: pointer;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      border: 2px solid rgba(255, 68, 68, 0.6);
      border-radius: 4px;
      text-decoration: none;
      color: #ff4444;
      text-transform: lowercase;
      letter-spacing: 1px;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      min-height: 26px;
      position: relative;
      overflow: hidden;
      background: 
        linear-gradient(135deg, rgba(20, 20, 40, 0.9) 0%, rgba(10, 10, 30, 0.95) 100%),
        repeating-linear-gradient(
          45deg,
          transparent,
          transparent 1px,
          rgba(255, 68, 68, 0.03) 1px,
          rgba(255, 68, 68, 0.03) 2px
        );
      box-shadow: 
        inset 0 1px 2px rgba(255, 68, 68, 0.2),
        inset 0 -1px 2px rgba(0, 0, 0, 0.5),
        0 2px 4px rgba(0, 0, 0, 0.6),
        0 0 12px rgba(255, 68, 68, 0.3),
        0 0 20px rgba(255, 68, 68, 0.2);
    }

    .btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, 
        transparent, 
        rgba(255, 68, 68, 0.3), 
        transparent
      );
      transition: left 0.4s;
    }

    .btn:hover::before {
      left: 100%;
    }

    .btn:hover {
      transform: translateY(-2px);
      border-color: #ff4444;
      box-shadow: 
        inset 0 1px 2px rgba(255, 68, 68, 0.4),
        inset 0 -1px 2px rgba(0, 0, 0, 0.5),
        0 4px 8px rgba(0, 0, 0, 0.7),
        0 0 20px rgba(255, 68, 68, 0.6),
        0 0 35px rgba(255, 68, 68, 0.4),
        0 0 50px rgba(255, 68, 68, 0.2);
      text-shadow: 
        0 0 10px rgba(255, 68, 68, 1),
        0 0 20px rgba(255, 68, 68, 0.8),
        0 0 30px rgba(255, 68, 68, 0.5);
    }

    .btn:active {
      transform: translateY(0);
      box-shadow: 
        inset 0 2px 4px rgba(0, 0, 0, 0.8),
        0 1px 2px rgba(0, 0, 0, 0.5);
    }

    .btn-large {
      padding: clamp(4px, 0.7vh, 5px) clamp(8px, 1.8vw, 12px);
      font-size: clamp(11px, 2.2vw, 13px);
      min-height: 28px;
    }

    .btn-primary {
      border-color: rgba(138, 43, 226, 0.6);
      color: #da70d6;
      box-shadow: 
        inset 0 1px 2px rgba(138, 43, 226, 0.2),
        inset 0 -1px 2px rgba(0, 0, 0, 0.5),
        0 2px 4px rgba(0, 0, 0, 0.6),
        0 0 8px rgba(138, 43, 226, 0.1);
    }
    
    .btn-primary:hover {
      border-color: #da70d6;
      color: #ff00ff;
      text-shadow: 0 0 8px rgba(255, 0, 255, 0.8);
      box-shadow: 
        inset 0 1px 2px rgba(138, 43, 226, 0.3),
        inset 0 -1px 2px rgba(0, 0, 0, 0.5),
        0 4px 8px rgba(0, 0, 0, 0.7),
        0 0 15px rgba(255, 0, 255, 0.4),
        0 0 25px rgba(255, 0, 255, 0.2);
    }

    .btn-success {
      border-color: rgba(0, 255, 127, 0.6);
      color: #00ff7f;
      box-shadow: 
        inset 0 1px 2px rgba(0, 255, 127, 0.2),
        inset 0 -1px 2px rgba(0, 0, 0, 0.5),
        0 2px 4px rgba(0, 0, 0, 0.6),
        0 0 8px rgba(0, 255, 127, 0.1),
        0 0 15px rgba(0, 255, 127, 0.2);
      animation: active-glow 2s ease-in-out infinite;
    }
    
    @keyframes active-glow {
      0%, 100% { 
        box-shadow: 
          inset 0 1px 2px rgba(0, 255, 127, 0.2),
          inset 0 -1px 2px rgba(0, 0, 0, 0.5),
          0 2px 4px rgba(0, 0, 0, 0.6),
          0 0 8px rgba(0, 255, 127, 0.1),
          0 0 15px rgba(0, 255, 127, 0.2);
      }
      50% { 
        box-shadow: 
          inset 0 1px 2px rgba(0, 255, 127, 0.3),
          inset 0 -1px 2px rgba(0, 0, 0, 0.5),
          0 2px 4px rgba(0, 0, 0, 0.6),
          0 0 12px rgba(0, 255, 127, 0.3),
          0 0 25px rgba(0, 255, 127, 0.4);
      }
    }

    .btn-success:hover {
      border-color: #00ff7f;
      color: #00ffaa;
      text-shadow: 0 0 10px rgba(0, 255, 127, 1);
    }

    .btn-danger {
      border-color: rgba(255, 20, 147, 0.6);
      color: #ff1493;
      box-shadow: 
        inset 0 1px 2px rgba(255, 20, 147, 0.2),
        inset 0 -1px 2px rgba(0, 0, 0, 0.5),
        0 2px 4px rgba(0, 0, 0, 0.6),
        0 0 8px rgba(255, 20, 147, 0.1);
    }

    .btn-danger:hover {
      border-color: #ff1493;
      color: #ff00ff;
      text-shadow: 0 0 10px rgba(255, 20, 147, 1);
      box-shadow: 
        inset 0 1px 2px rgba(255, 20, 147, 0.3),
        inset 0 -1px 2px rgba(0, 0, 0, 0.5),
        0 4px 8px rgba(0, 0, 0, 0.7),
        0 0 15px rgba(255, 20, 147, 0.4),
        0 0 25px rgba(255, 20, 147, 0.2);
    }

    .channel {
      text-transform: lowercase;
      letter-spacing: 1.5px;
    }

    h1, h2 {
      margin: clamp(12px, 2.5vh, 18px) 0 clamp(10px, 2vh, 14px) 0;
      font-size: clamp(22px, 5vw, 32px);
      font-weight: 700;
      font-family: 'Orbitron', 'Share Tech Mono', 'Courier New', 'Courier', 'Lucida Console', 'Monaco', 'Consolas';
      color: #00ffff;
      display: flex;
      align-items: center;
      gap: clamp(8px, 2vw, 12px);
      text-shadow: 
        0 0 10px rgba(0, 255, 255, 0.6),
        0 0 20px rgba(0, 255, 255, 0.3),
        2px 2px 4px rgba(0, 0, 0, 0.8);
      letter-spacing: 3px;
      text-transform: uppercase;
      position: relative;
    }
    
    h1::before, h2::before {
      content: '‚ñ∂';
      font-size: 0.6em;
      color: rgba(0, 255, 255, 0.5);
      margin-right: 8px;
      display: flex;
      align-items: center;
    }
    
    /* Remove play arrow from header h1 and h2 */
    header h1::before,
    header h2::before {
      content: none;
    }

    h1 span {
      font-weight: 400;
      text-transform: lowercase;
      letter-spacing: 2px;
    }
    
    h2 {
      font-size: clamp(16px, 3.5vw, 22px);
      color: rgba(0, 255, 255, 0.8);
      border-bottom: 1px solid rgba(0, 255, 255, 0.3);
      padding-bottom: 8px;
      margin-bottom: 12px;
    }
    
    /* Header h2 should not have border, padding, or margin */
    header h2 {
      border-bottom: none;
      padding-bottom: 0;
      margin-bottom: 0;
    }

    #metadata {
      margin-top: clamp(10px, 2vh, 14px);
      display: flex;
      align-items: center;
      gap: clamp(10px, 2.5vw, 14px);
      flex-wrap: wrap;
    }

    #metadata a {
      color: #ffd700;
      text-decoration: none;
      font-size: clamp(11px, 2vw, 13px);
      font-family: 'Share Tech Mono', 'Courier New', 'Courier', 'Lucida Console', 'Monaco', 'Consolas';
      padding: clamp(5px, 1vh, 6px) clamp(10px, 2vw, 12px);
      background: 
        linear-gradient(135deg, rgba(255, 215, 0, 0.15) 0%, rgba(255, 165, 0, 0.1) 100%);
      border: 1px solid rgba(255, 215, 0, 0.3);
      border-radius: 3px;
      transition: all 0.2s ease;
      text-shadow: 0 0 5px rgba(255, 215, 0, 0.5);
      box-shadow: 
        inset 0 1px 2px rgba(255, 215, 0, 0.2),
        0 0 8px rgba(255, 215, 0, 0.1);
    }

    #metadata a:hover {
      background: 
        linear-gradient(135deg, rgba(255, 215, 0, 0.25) 0%, rgba(255, 165, 0, 0.2) 100%);
      border-color: rgba(255, 215, 0, 0.6);
      transform: translateY(-1px);
      box-shadow: 
        inset 0 1px 2px rgba(255, 215, 0, 0.3),
        0 0 15px rgba(255, 215, 0, 0.3);
      text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
    }

    footer {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      padding: clamp(8px, 1.5vh, 12px) 0;
      background: 
        linear-gradient(180deg, rgba(10, 10, 20, 0.98) 0%, rgba(20, 20, 30, 0.95) 100%),
        repeating-linear-gradient(
          90deg,
          transparent,
          transparent 2px,
          rgba(0, 255, 255, 0.03) 2px,
          rgba(0, 255, 255, 0.03) 4px
        );
      backdrop-filter: blur(10px);
      border-top: 2px solid rgba(0, 255, 255, 0.3);
      z-index: 50; /* Below chat container so chat appears on top */
      box-shadow: 
        0 -4px 20px rgba(0, 0, 0, 0.8),
        inset 0 1px 0 rgba(0, 255, 255, 0.2),
        0 0 30px rgba(0, 255, 255, 0.1);
    }
    
    /* Desktop: adjust footer to not overlap chat container */
    @media (min-width: 769px) {
      footer {
        right: 350px; /* Leave space for chat container (350px wide) */
      }
    }
    
    footer::before {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 2px;
      background: linear-gradient(90deg, 
        transparent 0%,
        rgba(0, 255, 255, 0.8) 20%,
        rgba(255, 0, 255, 0.8) 50%,
        rgba(0, 255, 255, 0.8) 80%,
        transparent 100%
      );
      animation: pulse-glow 2s ease-in-out infinite;
    }

    footer .container {
      padding: clamp(6px, 1.2vh, 8px) clamp(12px, 2vw, 18px);
    }

    footer p {
      margin: 0;
      font-size: clamp(10px, 2.2vw, 12px);
      font-family: 'Share Tech Mono', 'Courier New', 'Courier', 'Lucida Console', 'Monaco', 'Consolas';
      line-height: 1.8;
      color: rgba(0, 255, 255, 0.7);
      text-align: right;
      text-shadow: 0 0 5px rgba(0, 255, 255, 0.3);
      letter-spacing: 0.5px;
    }

    footer a {
      color: #ffd700;
      text-decoration: none;
      transition: all 0.2s ease;
      text-shadow: 0 0 5px rgba(255, 215, 0, 0.5);
    }

    footer a:hover {
      color: #ffff00;
      text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
      text-decoration: none;
    }

    footer strong {
      color: #00ffff;
      font-weight: 700;
      text-shadow: 0 0 8px rgba(0, 255, 255, 0.6);
    }


    /* Responsive */
    @media (max-width: 768px) {
      html {
        font-size: 15px;
      }
      
      body {
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
      }
      
      header {
        padding: 0;
      }
      
      header .container {
        flex-direction: column;
        align-items: stretch;
        gap: clamp(6px, 1.2vh, 8px);
        padding: clamp(6px, 1.2vh, 8px) clamp(10px, 2.5vw, 12px);
      }
      
      header h1 {
        flex-direction: row;
        align-items: center;
        justify-content: center;
        width: 100%;
        margin: 0;
        font-size: clamp(14px, 3.5vw, 16px);
        letter-spacing: 1px;
      }
      
      header h1 .logo-icon {
        font-size: clamp(20px, 5vw, 24px) !important;
      }
      
      header h1 img {
        height: clamp(24px, 6vw, 28px);
      }
      
      .header-controls-wrapper {
        width: 100%;
        flex-direction: column;
        align-items: stretch;
        gap: clamp(4px, 1vh, 6px);
      }
      
      .header-controls-audio {
        width: 100%;
      }
      
      .header-channel-info {
        width: 100%;
      }
      
      .control-panel {
        width: 100%;
        justify-content: center;
        padding: clamp(6px, 1.2vh, 8px);
        gap: clamp(6px, 1.5vw, 8px);
      }
      
      header h2 {
        text-align: center;
        font-size: clamp(11px, 2.5vw, 13px);
        margin: 0;
        line-height: 1.3;
      }
      
      .current-song {
        text-align: center;
        font-size: clamp(9px, 2vw, 11px);
        line-height: 1.3;
        margin-top: 2px;
      }
      
      #channels {
        justify-content: flex-start;
      }
      
      .btn {
        white-space: normal;
        word-break: break-word;
        hyphens: auto;
        min-height: 44px;
        padding: clamp(8px, 1.5vh, 10px) clamp(12px, 3vw, 16px);
        font-size: clamp(12px, 2.5vw, 14px);
        touch-action: manipulation;
      }
      
      .btn-play-pause {
        align-self: center;
        min-width: 44px !important;
        min-height: 44px !important;
        font-size: clamp(16px, 4vw, 20px) !important;
        padding: clamp(6px, 1.2vh, 8px) !important;
      }
      
      .time-display {
        font-size: clamp(10px, 2.2vw, 12px) !important;
        padding: clamp(4px, 0.8vh, 6px) clamp(8px, 1.8vw, 10px) !important;
      }
      
      header .volume-control {
        display: none;
      }
      
      article {
        padding-top: clamp(8px, 1.5vh, 12px);
        padding-bottom: clamp(80px, 12vh, 100px);
      }
      
      footer {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
      }
    }
    
    @media (max-width: 480px) {
      html {
        font-size: 14px;
      }
      
      body {
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
      }
      
      header {
        padding: 0;
      }
      
      header .container {
        padding: clamp(4px, 1vh, 6px) clamp(8px, 2vw, 10px);
        gap: clamp(4px, 1vh, 6px);
      }
      
      header h1 {
        gap: 6px;
        font-size: clamp(12px, 3vw, 14px);
        letter-spacing: 0.5px;
      }
      
      header h1 .logo-icon {
        font-size: clamp(18px, 4.5vw, 20px) !important;
      }
      
      .header-controls-wrapper {
        gap: clamp(3px, 0.8vh, 4px);
      }
      
      .control-panel {
        padding: clamp(4px, 1vh, 6px);
        gap: clamp(4px, 1.2vw, 6px);
      }
      
      header h2 {
        font-size: clamp(10px, 2.2vw, 11px);
      }
      
      .current-song {
        font-size: clamp(8px, 1.8vw, 10px);
      }
      
      #channels {
        gap: 8px;
      }
      
      .btn-large {
        padding: clamp(10px, 2vh, 12px) clamp(14px, 3vw, 16px);
        font-size: clamp(12px, 2.5vw, 13px);
        min-height: 44px;
      }
      
      h1, h2 {
        font-size: clamp(16px, 4vw, 20px);
      }
      
      footer p {
        line-height: 1.5;
        font-size: clamp(9px, 2vw, 11px);
        text-align: center;
      }
      
      .time-display {
        font-size: clamp(9px, 2vw, 11px) !important;
        padding: clamp(3px, 0.6vh, 5px) clamp(6px, 1.5vw, 8px) !important;
      }
      
      .btn-play-pause {
        min-width: 40px !important;
        min-height: 40px !important;
        font-size: clamp(14px, 3.5vw, 18px) !important;
        padding: clamp(4px, 1vh, 6px) !important;
      }
      
      header .volume-control {
        display: none;
      }
      
      article {
        padding-top: clamp(6px, 1.2vh, 8px);
      }
    }
    
    /* Desktop styles - restore horizontal layout */
    @media (min-width: 769px) {
      .chat-toggle-btn {
        display: none !important;
      }
      header {
        padding: 0;
      }
      
      header .container {
        flex-direction: row !important;
        align-items: center;
        gap: clamp(12px, 2vw, 16px);
        padding: clamp(8px, 1.2vh, 12px) clamp(12px, 2vw, 20px);
        flex-wrap: nowrap;
      }
      
      header h1 {
        flex-direction: row !important;
        align-items: center;
        justify-content: flex-start;
        width: auto !important;
        margin: 0;
        font-size: clamp(20px, 3vw, 24px);
        letter-spacing: 2px;
        flex-shrink: 0;
      }
      
      header h1 .logo-icon {
        font-size: clamp(32px, 5vw, 42px) !important;
      }
      
      .header-controls-wrapper {
        width: auto !important;
        flex-direction: row !important;
        flex: 1;
        min-width: 0;
        flex-wrap: nowrap;
      }
      
      .header-controls-audio {
        flex: 0 0 auto !important;
        width: auto !important;
        min-width: 0 !important;
      }
      
      .header-channel-info {
        width: auto !important;
        flex: 1;
        min-width: 0;
      }
      
      .control-panel {
        width: auto !important;
        justify-content: flex-start;
        padding: clamp(10px, 1.5vh, 14px);
        gap: clamp(10px, 2vw, 14px);
        flex-shrink: 0;
      }
      
      header h2 {
        text-align: left !important;
        font-size: clamp(16px, 2.5vw, 22px);
        margin: 0;
        line-height: 1.2;
      }
      
      .current-song {
        text-align: left !important;
        font-size: clamp(12px, 2vw, 16px);
        line-height: 1.4;
        margin-top: 2px;
      }
      
      .btn-play-pause {
        min-width: 50px !important;
        min-height: 50px !important;
        font-size: clamp(18px, 3vw, 24px) !important;
        padding: clamp(8px, 1.2vh, 12px) !important;
      }
      
      .time-display {
        font-size: clamp(13px, 2vw, 16px) !important;
        padding: clamp(8px, 1.2vh, 10px) clamp(10px, 1.8vw, 12px) !important;
      }
      
      header .volume-control {
        display: flex !important;
        width: auto !important;
        flex-direction: column !important;
        justify-content: center;
        align-items: center;
        gap: 6px;
        padding: 8px 12px;
        margin-left: auto;
        flex-shrink: 0;
      }
      
      header .volume-control input[type="range"] {
        transform: rotate(-90deg) !important;
        writing-mode: bt-lr !important;
        width: 80px !important;
        height: 6px !important;
        margin: 25px 0 !important;
      }
      
      header .volume-control span {
        font-size: clamp(14px, 2vw, 18px);
      }
      
      article {
        padding-top: clamp(12px, 2.5vh, 24px);
      }
    }
    
    @media (min-width: 1200px) {
      html {
        font-size: 18px;
      }
      
      header h1 {
        font-size: 24px;
      }
      
      header h1 .logo-icon {
        font-size: 42px !important;
      }
      
      header h2 {
        font-size: 22px;
      }
      
      .current-song {
        font-size: 16px;
      }
    }
    
    @media (min-width: 1600px) {
      html {
        font-size: 20px;
      }
    }

    /* Play/Pause button styling */
    .btn-play-pause {
      min-width: 50px !important;
      min-height: 50px !important;
      border-radius: 50% !important;
      font-size: clamp(18px, 4vw, 24px) !important;
      padding: clamp(8px, 1.5vh, 12px) !important;
      background: 
        radial-gradient(circle, rgba(255, 68, 68, 0.2) 0%, rgba(200, 0, 0, 0.1) 100%),
        linear-gradient(135deg, rgba(20, 20, 40, 0.9) 0%, rgba(10, 10, 30, 0.95) 100%) !important;
      border: 2px solid rgba(255, 68, 68, 0.6) !important;
      box-shadow: 
        inset 0 2px 4px rgba(255, 68, 68, 0.3),
        inset 0 -2px 4px rgba(0, 0, 0, 0.6),
        0 4px 8px rgba(0, 0, 0, 0.7),
        0 0 20px rgba(255, 68, 68, 0.5),
        0 0 35px rgba(255, 68, 68, 0.3) !important;
    }
    
    .btn-play-pause:hover {
      border-color: rgba(255, 68, 68, 1) !important;
      box-shadow: 
        inset 0 2px 4px rgba(255, 68, 68, 0.4),
        inset 0 -2px 4px rgba(0, 0, 0, 0.6),
        0 6px 12px rgba(0, 0, 0, 0.8),
        0 0 30px rgba(255, 68, 68, 0.8),
        0 0 50px rgba(255, 68, 68, 0.6),
        0 0 70px rgba(255, 68, 68, 0.3) !important;
      transform: scale(1.05) !important;
    }
    
    .btn-play-pause:active {
      transform: scale(0.95) !important;
    }
    
    /* Time display styling */
    .time-display {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: clamp(12px, 2.5vw, 16px);
      font-family: 'Share Tech Mono', 'Courier New', 'Courier', 'Lucida Console', 'Monaco', 'Consolas';
      color: #00ffff;
      text-shadow: 
        0 0 10px rgba(0, 255, 255, 1),
        0 0 20px rgba(0, 255, 255, 0.7),
        0 0 30px rgba(0, 255, 255, 0.4);
      padding: 8px 12px;
      background: 
        linear-gradient(135deg, rgba(0, 0, 0, 0.6) 0%, rgba(10, 10, 30, 0.8) 100%);
      border: 1px solid rgba(0, 255, 255, 0.4);
      border-radius: 4px;
      box-shadow: 
        inset 0 1px 2px rgba(0, 255, 255, 0.2),
        0 0 15px rgba(0, 255, 255, 0.4),
        0 0 25px rgba(0, 255, 255, 0.2);
      letter-spacing: 2px;
    }
    
    /* Control panel styling */
    .control-panel {
      display: flex;
      align-items: center;
      gap: clamp(10px, 2vw, 14px);
      flex-wrap: wrap;
      padding: 10px 14px;
      background: 
        linear-gradient(135deg, rgba(20, 20, 40, 0.6) 0%, rgba(10, 10, 30, 0.8) 100%);
      border: 1px solid rgba(0, 255, 255, 0.2);
      border-radius: 6px;
      box-shadow: 
        inset 0 1px 2px rgba(0, 255, 255, 0.2),
        0 0 20px rgba(0, 255, 255, 0.3),
        0 0 30px rgba(0, 255, 255, 0.2);
      line-height: 1;
    }
    
    /* Channel name display */
    header h2 {
      margin: 0;
      font-size: clamp(16px, 3.5vw, 22px);
      font-weight: 400;
      font-family: 'Share Tech Mono', 'Courier New', 'Courier', 'Lucida Console', 'Monaco', 'Consolas';
      color: #00ffff;
      text-shadow: 
        0 0 10px rgba(0, 255, 255, 0.9),
        0 0 20px rgba(0, 255, 255, 0.6),
        0 0 30px rgba(0, 255, 255, 0.3);
      letter-spacing: 1px;
      display: flex;
      align-items: center;
      line-height: 1.2;
    }
    
    header h2 a {
      color: inherit;
      text-decoration: none;
      transition: all 0.2s ease;
    }
    
    header h2 a:hover {
      color: #ffff00;
      text-shadow: 
        0 0 15px rgba(255, 255, 0, 1),
        0 0 30px rgba(255, 255, 0, 0.7),
        0 0 45px rgba(255, 255, 0, 0.4);
    }
    
    .current-song {
      font-size: clamp(12px, 2.5vw, 16px);
      font-family: 'Share Tech Mono', 'Courier New', 'Courier', 'Lucida Console', 'Monaco', 'Consolas';
      color: rgba(0, 255, 255, 0.8);
      text-shadow: 
        0 0 8px rgba(0, 255, 255, 0.6),
        0 0 16px rgba(0, 255, 255, 0.3);
      letter-spacing: 0.5px;
      line-height: 1.4;
      margin-top: 2px;
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }
    
    .add-song-btn {
      background: rgba(0, 255, 255, 0.1);
      border: 1px solid rgba(0, 255, 255, 0.4);
      border-radius: 4px;
      color: rgba(0, 255, 255, 0.8);
      font-size: clamp(10px, 1.8vw, 12px);
      padding: 2px 6px;
      cursor: pointer;
      font-family: 'Share Tech Mono', monospace;
      text-shadow: 0 0 4px rgba(0, 255, 255, 0.5);
      white-space: nowrap;
    }
    
    .add-song-btn:hover {
      background: rgba(0, 255, 255, 0.2);
      border-color: rgba(0, 255, 255, 0.7);
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.4);
    }

    /* Smooth transitions */
    * {
      transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
    }
    
    /* Chat iframe container */
    .chat-container {
      position: fixed;
      right: 0;
      top: 0;
      bottom: 0;
      width: 350px;
      z-index: 200; /* Above footer (50) so it appears on top */
      border-left: 2px solid rgba(0, 255, 255, 0.4);
      background: rgba(10, 10, 20, 0.95);
      backdrop-filter: blur(10px);
      box-shadow: 
        -4px 0 20px rgba(0, 0, 0, 0.8),
        inset 1px 0 0 rgba(0, 255, 255, 0.3),
        0 0 40px rgba(0, 255, 255, 0.1);
    }
    
    .chat-container iframe {
      width: 100%;
      height: 100%;
      border: none;
      background: transparent;
    }
    
    /* Mobile chat toggle button */
    .chat-toggle-btn {
      position: fixed;
      bottom: 80px;
      right: 20px;
      z-index: 250; /* Above chat container (200) so it's always clickable */
      padding: 0;
      background: 
        linear-gradient(135deg, rgba(20, 20, 40, 0.9) 0%, rgba(10, 10, 30, 0.95) 100%);
      border: 2px solid rgba(0, 255, 255, 0.6);
      border-radius: 50%;
      color: #00ffff;
      font-size: 20px;
      cursor: pointer;
      box-shadow: 
        0 0 20px rgba(0, 255, 255, 0.5),
        0 0 40px rgba(0, 255, 255, 0.3);
      width: 56px;
      height: 56px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      font-family: 'Share Tech Mono', 'Courier New', 'Courier', 'Lucida Console', 'Monaco', 'Consolas';
    }
    
    /* Close button style when chat is open */
    .chat-toggle-btn.is-open {
      border-color: rgba(255, 0, 255, 0.6);
      box-shadow: 
        0 0 20px rgba(255, 0, 255, 0.5),
        0 0 40px rgba(255, 0, 255, 0.3);
    }
    
    .chat-toggle-btn:hover {
      box-shadow: 
        0 0 30px rgba(0, 255, 255, 0.8),
        0 0 60px rgba(0, 255, 255, 0.5);
      transform: scale(1.1);
    }
    
    /* Mobile chat container */
    @media (max-width: 768px) {
      .chat-container {
        position: fixed;
        right: 0;
        top: 0;
        bottom: 0;
        left: 0;
        width: 100%;
        transform: translateX(100%);
        transition: transform 0.3s ease;
        z-index: 200; /* Above footer on mobile too */
        /* Ensure chat doesn't interfere when hidden */
        pointer-events: none;
      }
      
      .chat-container.visible {
        transform: translateX(0);
        pointer-events: auto;
      }
      
      /* Ensure main content is not blocked on mobile */
      article {
        margin-right: 0 !important;
      }
    }
    
    /* Desktop: adjust article margin when chat is visible */
    @media (min-width: 769px) {
      article {
        margin-right: 350px;
      }
    }
  </style>
</head>
<body x-data="radioApp()" x-init="init()">
  <div class="container">
    <!-- Player Header -->
    <header>
      <div class="container">
        <h1>
          <span class="logo-icon">üìª</span>
          radio guaka
        </h1>

        <div class="header-controls-wrapper">
          <template x-if="srcUrl">
            <div class="header-controls-audio">
              <audio preload="auto" id="player" :src="srcUrl" x-ref="audioPlayer" style="display: none;">
              </audio>

              <div class="control-panel">
                <button @click="togglePlay()" class="btn btn-play-pause" style="touch-action: manipulation;">
                  <span x-text="isPlaying ? '‚è∏' : '‚ñ∂'"></span>
                </button>
                
                <div class="time-display">
                  <span x-text="formatTime(currentTime)"></span>
                </div>
              </div>
            </div>
          </template>
          
          <template x-if="currentChannelData">
            <div class="header-channel-info">
              <h2>
                <template x-if="currentChannelData.site">
                  <a :href="currentChannelData.site" target="_blank" style="color: inherit; text-decoration: none; transition: color 0.2s ease;" 
                     onmouseover="this.style.color='#ffff00'"
                     onmouseout="this.style.color=''">
                    <span x-text="currentChannelData.name.replace(/^flux_fm_/, 'flux ').replace(/_/g, ' ')"></span>
                  </a>
                </template>
                <template x-if="!currentChannelData.site">
                  <span x-text="currentChannelData.name.replace(/^flux_fm_/, 'flux ').replace(/_/g, ' ')"></span>
                </template>
              </h2>
              <template x-if="currentSong">
                <div class="current-song">
                  <span x-text="currentSong.artist && currentSong.title ? currentSong.artist + ' - ' + currentSong.title : (currentSong.title || '')"></span>
                  <button class="add-song-btn" 
                          @click="sendSongToChat()" 
                          title="Add song to chat">+üí¨</button>
                </div>
              </template>
            </div>
          </template>
        </div>
        
        <div class="volume-control">
          <span style="font-size: clamp(10px, 1.5vw, 12px); color: #aaa;">üîä</span>
          <input type="range" 
                 min="0" 
                 max="1" 
                 step="0.01" 
                 @input="setVolume($event.target.value)"
                 :value="volume"
                 title="Volume">
        </div>
      </div>
    </header>

    <!-- Main Content -->
    <article>
      <div class="container">
        <div id="channels" style="clear:both; width: 100%; max-width: 100%;">
          <template x-for="channel in otherChannels" :key="channel.name">
            <a href="#"
               @click.prevent="navigateTo('#' + channel.name)"
               class="channel btn btn-large"
               :class="channel.playing ? 'btn-success' : 'btn-primary'">
              <span x-text="channel.name"></span>
            </a>
          </template>
          
          <template x-for="section in sortedSections" :key="section.name">
            <template x-if="getSectionChannels(section).length > 0">
              <div>
                <h2 style="width: 100%; margin: clamp(10px, 2vh, 15px) 0 clamp(6px, 1.2vh, 10px) 0; font-size: clamp(13px, 2.5vw, 15px); font-weight: 300; color: #fff;" x-text="section.name"></h2>
                
                <template x-for="channel in getSectionChannels(section)" :key="channel.name">
                  <a href="#"
                     @click.prevent="navigateTo('#' + channel.name)"
                     class="channel btn btn-large"
                     :class="channel.playing ? 'btn-success' : 'btn-primary'">
                    <span x-text="formatChannelName(channel.name, section.name)"></span>
                  </a>
                </template>
              </div>
            </template>
          </template>
        </div>

      </div>
    </article>
    
    <!-- Chat iframe -->
    <div class="chat-container" 
         :class="{ 'visible': isChatVisible }"
         x-show="(isChatVisible && window.innerWidth < 769) || window.innerWidth >= 769"
         x-ref="chatContainer">
      <iframe 
        :src="chatIframeSrc"
        x-ref="chatIframe"
        @load="onChatIframeLoad()">
      </iframe>
    </div>
    
    <!-- Mobile chat toggle button -->
    <template x-if="window.innerWidth < 769">
      <button 
        class="chat-toggle-btn"
        :class="{ 'is-open': isChatVisible }"
        @click="toggleChat()"
        :title="isChatVisible ? 'Close chat' : 'Open chat'">
        <span x-text="isChatVisible ? '‚úï' : 'üí¨'"></span>
      </button>
    </template>
    
    <!-- Footer -->
    <footer>
      <div class="container">
          <p>
          ‚å® shortcuts:
          Change volume ‚Üë ‚Üì
          Change channels ‚Üê ‚Üí
          or press first letter of the name. ‚è∏ space bar to play/pause.

          <a target="_blank" href="https://github.com/guaka/radio-meteor/"><span>üì¶</span></a> <a target="_blank" href="https://github.com/guaka/radio">free software</a>
          <span x-text="buildDate" style="margin-left: 12px; color: rgba(0, 255, 255, 0.5); font-size: 10px;"></span>
        </p>
      </div>
    </footer>
  </div>

  <script>
    // Load build time (Jekyll-processed on GH Pages, may fail locally)
    window.BUILD_TIME = '';
    fetch('buildtime.js')
      .then(r => r.text())
      .then(text => {
        // Extract the BUILD_TIME value from the processed JS
        const match = text.match(/BUILD_TIME\s*=\s*'([^']+)'/);
        if (match && /^\d/.test(match[1])) {
          window.BUILD_TIME = match[1];
        }
      })
      .catch(() => {});
  </script>
  <script src="channels.js"></script>
  <script>
    // Network and ready state mappings
    const networkStates = {
      0: 'empty',
      1: 'idle',
      2: 'loading',
      3: 'no source'
    };

    const readyStates = {
      0: 'nothing',
      1: 'metadata',
      2: 'current',
      3: 'future',
      4: 'enough'
    };

    // Radio Tuning Noise Generator - Enhanced FM Radio Static
    class RadioTuningNoise {
      constructor() {
        this.audioContext = null;
        this.noiseSources = [];
        this.gainNode = null;
        this.biquadFilter = null;
        this.oscillators = [];
        this.intervals = [];
        this.isPlaying = false;
        this.volume = 0.5; // Volume for tuning noise (0-1)
        this.nodes = []; // Track all nodes for cleanup
      }
      
      init() {
        try {
          // Create audio context if not already created
          if (!this.audioContext) {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            this.audioContext = new AudioContext();
          }
          
          // Resume context if suspended (required for autoplay policies)
          if (this.audioContext.state === 'suspended') {
            this.audioContext.resume();
          }
        } catch (e) {
          console.log('Web Audio API not supported:', e);
          return false;
        }
        return true;
      }
      
      play() {
        if (this.isPlaying) return;
        
        if (!this.init()) return;
        
        try {
          const now = this.audioContext.currentTime;
          const sampleRate = this.audioContext.sampleRate;
          
          // Create multiple noise buffers with different characteristics
          const bufferSize = sampleRate * 3; // 3 seconds
          
          // Main pink noise buffer (base static)
          const pinkBuffer = this.audioContext.createBuffer(1, bufferSize, sampleRate);
          const pinkData = pinkBuffer.getChannelData(0);
          let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0;
          for (let i = 0; i < bufferSize; i++) {
            const white = Math.random() * 2 - 1;
            b0 = 0.99886 * b0 + white * 0.0555179;
            b1 = 0.99332 * b1 + white * 0.0750759;
            b2 = 0.96900 * b2 + white * 0.1538520;
            b3 = 0.86650 * b3 + white * 0.3104856;
            b4 = 0.55000 * b4 + white * 0.5329522;
            b5 = -0.7616 * b5 - white * 0.0168980;
            pinkData[i] = (b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362) * 0.12;
            b6 = white * 0.115926;
          }
          
          // High-frequency white noise buffer (for FM hiss)
          const whiteBuffer = this.audioContext.createBuffer(1, bufferSize, sampleRate);
          const whiteData = whiteBuffer.getChannelData(0);
          for (let i = 0; i < bufferSize; i++) {
            whiteData[i] = (Math.random() * 2 - 1) * 0.08;
          }
          
          // Create noise sources
          const pinkSource = this.audioContext.createBufferSource();
          pinkSource.buffer = pinkBuffer;
          pinkSource.loop = true;
          
          const whiteSource = this.audioContext.createBufferSource();
          whiteSource.buffer = whiteBuffer;
          whiteSource.loop = true;
          
          this.noiseSources = [pinkSource, whiteSource];
          
          // Create main bandpass filter for tuning effect
          this.biquadFilter = this.audioContext.createBiquadFilter();
          this.biquadFilter.type = 'bandpass';
          this.biquadFilter.frequency.value = 2000; // Lower center frequency
          this.biquadFilter.Q.value = 10;
          
          // Create secondary bandpass for texture
          const bandpass2 = this.audioContext.createBiquadFilter();
          bandpass2.type = 'bandpass';
          bandpass2.frequency.value = 3500; // Lower frequency
          bandpass2.Q.value = 5;
          
          // High-pass filter (remove rumble)
          const highPass = this.audioContext.createBiquadFilter();
          highPass.type = 'highpass';
          highPass.frequency.value = 300; // Lower cutoff
          highPass.Q.value = 0.7;
          
          // Low-pass filter (FM bandwidth limit)
          const lowPass = this.audioContext.createBiquadFilter();
          lowPass.type = 'lowpass';
          lowPass.frequency.value = 18000;
          lowPass.Q.value = 0.7;
          
          // High-frequency emphasis (FM has good highs)
          const highShelf = this.audioContext.createBiquadFilter();
          highShelf.type = 'highshelf';
          highShelf.frequency.value = 6000; // Lower frequency
          highShelf.gain.value = 3; // Boost highs slightly
          
          // Create gain nodes - slightly louder
          const pinkGain = this.audioContext.createGain();
          pinkGain.gain.value = 0.8;
          
          const whiteGain = this.audioContext.createGain();
          whiteGain.gain.value = 0.6;
          
          this.gainNode = this.audioContext.createGain();
          this.gainNode.gain.value = 0;
          
          // Create master merger
          const merger = this.audioContext.createChannelMerger(1);
          
          // Connect pink noise chain
          pinkSource.connect(pinkGain);
          pinkGain.connect(highPass);
          highPass.connect(this.biquadFilter);
          this.biquadFilter.connect(bandpass2);
          bandpass2.connect(lowPass);
          lowPass.connect(highShelf);
          highShelf.connect(merger, 0, 0);
          
          // Connect white noise (high-frequency hiss)
          whiteSource.connect(whiteGain);
          whiteGain.connect(bandpass2);
          
          // Connect to output
          merger.connect(this.gainNode);
          this.gainNode.connect(this.audioContext.destination);
          
          // Create frequency modulation (less variation)
          // Main slow sweep - more consistent
          const mainSweep = this.audioContext.createOscillator();
          mainSweep.type = 'sine';
          mainSweep.frequency.value = 0.3; // Fixed, less variation
          
          // Fast sweep - more consistent
          const fastSweep = this.audioContext.createOscillator();
          fastSweep.type = 'triangle';
          fastSweep.frequency.value = 2.0; // Fixed, less variation
          
          // Slow random walk oscillator (reduced variation)
          const randomWalk = this.audioContext.createOscillator();
          randomWalk.type = 'sawtooth';
          randomWalk.frequency.value = 0.12; // Fixed, less variation
          
          // Modulation gains - more consistent
          const modGain1 = this.audioContext.createGain();
          modGain1.gain.value = 1800; // Fixed, less variation
          
          const modGain2 = this.audioContext.createGain();
          modGain2.gain.value = 1000; // Fixed, less variation
          
          const modGain3 = this.audioContext.createGain();
          modGain3.gain.value = 600; // Fixed, less variation
          
          // Combine modulations
          const modMerger = this.audioContext.createChannelMerger(1);
          mainSweep.connect(modGain1);
          fastSweep.connect(modGain2);
          randomWalk.connect(modGain3);
          modGain1.connect(modMerger, 0, 0);
          modGain2.connect(modMerger, 0, 0);
          modGain3.connect(modMerger, 0, 0);
          
          // Connect to filter frequency
          modMerger.connect(this.biquadFilter.frequency);
          
          // Dynamic Q variation (signal strength simulation) - reduced variation
          const qVariation = this.audioContext.createOscillator();
          qVariation.type = 'sine';
          qVariation.frequency.value = 0.7; // Fixed, less variation
          const qGain = this.audioContext.createGain();
          qGain.gain.value = 3.5; // Fixed, less variation
          qVariation.connect(qGain);
          qGain.connect(this.biquadFilter.Q);
          
          // Amplitude modulation for texture - reduced variation
          const ampMod = this.audioContext.createOscillator();
          ampMod.type = 'sine';
          ampMod.frequency.value = 3.5; // Fixed, less variation
          const ampGain = this.audioContext.createGain();
          ampGain.gain.value = 0.12; // Slightly reduced
          ampMod.connect(ampGain);
          ampGain.connect(pinkGain.gain);
          
          // Store nodes
          this.nodes = [
            mainSweep, fastSweep, randomWalk, modGain1, modGain2, modGain3, modMerger,
            highPass, bandpass2, lowPass, highShelf, pinkGain, whiteGain, merger,
            qVariation, qGain, ampMod, ampGain
          ];
          this.oscillators = [mainSweep, fastSweep, randomWalk, qVariation, ampMod];
          
          // Start sources
          pinkSource.start(0);
          whiteSource.start(0);
          mainSweep.start(0);
          fastSweep.start(0);
          randomWalk.start(0);
          qVariation.start(0);
          ampMod.start(0);
          
          // Add crackling/pops
          const crackleGain = this.audioContext.createGain();
          crackleGain.gain.value = 0;
          pinkSource.connect(crackleGain);
          crackleGain.connect(this.gainNode);
          
          const crackleInterval = setInterval(() => {
            if (this.isPlaying && crackleGain && this.audioContext) {
              const crackleTime = this.audioContext.currentTime;
              const intensity = 0.3 + Math.random() * 0.4;
              crackleGain.gain.setValueAtTime(0, crackleTime);
              crackleGain.gain.setValueAtTime(intensity, crackleTime);
              crackleGain.gain.exponentialRampToValueAtTime(0.001, crackleTime + 0.03 + Math.random() * 0.04);
            }
          }, 80 + Math.random() * 180);
          
          this.intervals.push(crackleInterval);
          this.nodes.push(crackleGain);
          
          // Add brief "station-like" peaks (moments where you almost hear something)
          const stationPeakGain = this.audioContext.createGain();
          stationPeakGain.gain.value = 0;
          pinkSource.connect(stationPeakGain);
          
          // Filter for station peaks (voice-like frequencies) - lower frequencies
          const stationFilter = this.audioContext.createBiquadFilter();
          stationFilter.type = 'bandpass';
          stationFilter.frequency.value = 1500; // Lower frequency
          stationFilter.Q.value = 15;
          stationPeakGain.connect(stationFilter);
          stationFilter.connect(this.gainNode);
          
          const stationInterval = setInterval(() => {
            if (this.isPlaying && stationPeakGain && this.audioContext && Math.random() > 0.7) {
              const peakTime = this.audioContext.currentTime;
              const duration = 0.1 + Math.random() * 0.2;
              const freq = 1200 + Math.random() * 1500; // Lower frequency range
              
              stationFilter.frequency.setValueAtTime(freq, peakTime);
              stationPeakGain.gain.setValueAtTime(0, peakTime);
              stationPeakGain.gain.linearRampToValueAtTime(0.25 + Math.random() * 0.15, peakTime + 0.05);
              stationPeakGain.gain.linearRampToValueAtTime(0, peakTime + duration);
            }
          }, 300 + Math.random() * 500);
          
          this.intervals.push(stationInterval);
          this.nodes.push(stationPeakGain, stationFilter);
          
          // Random frequency jumps (like tuning knob movement) - reduced frequency
          const freqJumpInterval = setInterval(() => {
            if (this.isPlaying && this.biquadFilter && this.audioContext && Math.random() > 0.92) {
              const jumpTime = this.audioContext.currentTime;
              const currentFreq = this.biquadFilter.frequency.value;
              const newFreq = currentFreq + (Math.random() - 0.5) * 1500; // Smaller jumps
              this.biquadFilter.frequency.setValueAtTime(currentFreq, jumpTime);
              this.biquadFilter.frequency.linearRampToValueAtTime(newFreq, jumpTime + 0.15);
            }
          }, 400 + Math.random() * 400); // Less frequent jumps
          
          this.intervals.push(freqJumpInterval);
          
          // Fade in
          this.gainNode.gain.setValueAtTime(0, now);
          this.gainNode.gain.linearRampToValueAtTime(this.volume, now + 0.2);
          
          this.isPlaying = true;
        } catch (e) {
          console.log('Error playing tuning noise:', e);
        }
      }
      
      stop() {
        if (!this.isPlaying) return;
        
        try {
          // Clear all intervals
          this.intervals.forEach(interval => {
            clearInterval(interval);
          });
          this.intervals = [];
          
          // Fade out smoothly
          if (this.gainNode && this.audioContext) {
            const now = this.audioContext.currentTime;
            this.gainNode.gain.setValueAtTime(this.volume, now);
            this.gainNode.gain.linearRampToValueAtTime(0, now + 0.25);
            
            // Stop sources after fade out
            setTimeout(() => {
              // Stop all oscillators
              this.oscillators.forEach(osc => {
                try {
                  osc.stop();
                } catch (e) {
                  // Already stopped
                }
              });
              
              // Stop all noise sources
              this.noiseSources.forEach(source => {
                try {
                  source.stop();
                } catch (e) {
                  // Already stopped
                }
              });
              
              // Clean up all nodes
              this.nodes = [];
              this.oscillators = [];
              this.noiseSources = [];
              this.biquadFilter = null;
              this.gainNode = null;
              this.isPlaying = false;
            }, 300);
          } else {
            this.isPlaying = false;
          }
        } catch (e) {
          console.log('Error stopping tuning noise:', e);
          this.isPlaying = false;
        }
      }
    }

    // Player class
    class RadioPlayer {
      constructor() {
        this.readyState = null;
        this.networkState = null;
        this.tuningNoise = new RadioTuningNoise();
        
        // Check status every 7 seconds
        setInterval(() => {
          if (this.audioTag()) {
            this.checkStatus();
          }
        }, 7000);
      }
      
      audioTag() {
        return document.getElementById('player');
      }
      
      play() {
        const audio = this.audioTag();
        if (audio) {
          audio.play();
        }
      }
      
      setChannel(channel, appState, shouldAutoplay = true) {
        this.readyState = null;
        this.networkState = null;
        
        if (appState) {
          appState.currentChannel = channel;
        }
        
        // Get the expected source URL
        const expectedSrc = this.getExpectedSrc(channel);
        
        // Wait for audio element to be available (it's conditionally rendered by Alpine)
        const waitForAudioAndPlay = () => {
          const audio = this.audioTag();
          
          if (!audio) {
            // Audio element not rendered yet, wait a bit and try again
            if (expectedSrc) {
              setTimeout(waitForAudioAndPlay, 50);
            }
            return;
          }
          
          // Remove any existing event listeners to prevent duplicates
          const playWhenReady = () => {
            // Don't stop tuning noise here - only stop when playback actually starts
            // Only autoplay if shouldAutoplay is true and user hasn't manually paused
            if (shouldAutoplay && (!appState || !appState.userPaused)) {
              const playPromise = audio.play();
              if (playPromise !== undefined) {
                playPromise.then(() => {
                  // Stop tuning noise only when playback actually starts
                  if (this.tuningNoise) {
                    this.tuningNoise.stop();
                  }
                }).catch(error => {
                  // Autoplay was prevented - keep noise playing
                  // User can manually click play if needed
                  console.log('Autoplay prevented:', error);
                });
              }
            }
          };
          
          // Remove old listeners if they exist
          if (this._canPlayListener) {
            audio.removeEventListener('canplay', this._canPlayListener);
          }
          if (this._loadedDataListener) {
            audio.removeEventListener('loadeddata', this._loadedDataListener);
          }
          
          // Audio element exists, now set src and play
          audio.pause();
          
          // Set volume from app state if available
          if (appState && appState.volume !== undefined) {
            audio.volume = appState.volume;
          }
          
          if (expectedSrc) {
            // Set src directly - Alpine binding will also update but we need immediate control
            // Convert to absolute URL if needed for comparison
            const currentSrc = audio.src;
            const expectedSrcAbsolute = new URL(expectedSrc, window.location.href).href;
            
            // Only change src if it's different to avoid unnecessary reloads
            if (currentSrc !== expectedSrcAbsolute && currentSrc !== expectedSrc) {
              audio.src = expectedSrc;
              audio.load();
            } else if (audio.readyState === 0) {
              // If src is already correct but not loaded, load it
              audio.load();
            }
            
            // Create event listeners for when audio is ready
            this._canPlayListener = playWhenReady;
            this._loadedDataListener = playWhenReady;
            
            // Add listeners for when audio is ready to play
            audio.addEventListener('canplay', this._canPlayListener, { once: true });
            audio.addEventListener('loadeddata', this._loadedDataListener, { once: true });
            
            // Stop tuning noise only when playback actually starts
            const playingHandler = () => {
              if (this.tuningNoise) {
                this.tuningNoise.stop();
              }
            };
            audio.addEventListener('playing', playingHandler, { once: true });
            
            // Don't stop noise on error - keep it playing if stream fails
            const errorHandler = () => {
              // Keep tuning noise playing if stream fails
              console.log('Stream error - keeping tuning noise');
            };
            audio.addEventListener('error', errorHandler, { once: true });
            
            // Try to play immediately if shouldAutoplay and user hasn't paused
            // If it fails, the event listeners will retry when ready
            // Note: tuning noise will stop on 'playing' event, not here
            if (shouldAutoplay && (!appState || !appState.userPaused)) {
              setTimeout(() => {
                const playPromise = audio.play();
                if (playPromise !== undefined) {
                  playPromise.catch(error => {
                    // Autoplay was prevented - event listeners will retry when ready
                    // Keep tuning noise playing
                    console.log('Immediate autoplay prevented, will retry when ready:', error);
                  });
                }
              }, 50);
            }
          } else {
            audio.src = '';
          }
        };
        
        // Start waiting for audio element
        waitForAudioAndPlay();
      }
      
      getExpectedSrc(channel) {
        if (!channel) return null;
        
        const channelData = channels[channel];
        if (!channelData) {
          console.warn('Channel not found:', channel);
          return null;
        }
        
        // SomaFM streams use a pattern
        if (channelData.tags && channelData.tags.indexOf('soma') > -1) {
          return 'https://ice.somafm.com/' + channel;
        }
        
        const url = channelData.url || null;
        if (!url) {
          console.warn('Channel has no URL:', channel);
        }
        return url;
      }
      
      checkStatus() {
        const audio = this.audioTag();
        if (!audio) return;
        
        const newNetworkState = audio.networkState;
        const newReadyState = audio.readyState;
        
        // Only auto-play if audio is paused, user hasn't manually paused, and we have a channel
        if (audio.paused && 
            (!window.appState || !window.appState.userPaused) &&
            window.appState?.currentChannel) {
          this.play();
        }
        
        // Check if we need to restart (stuck state)
        if (this.readyState !== null &&
            newReadyState === this.readyState &&
            [0, 1].indexOf(newReadyState) > -1 &&
            newNetworkState !== 2) {
          console.log('Restart channel');
          this.readyState = null;
          this.networkState = null;
          const currentChannel = window.appState?.currentChannel || '';
          const shouldAutoplay = !window.appState || !window.appState.userPaused;
          this.setChannel(currentChannel, window.appState, shouldAutoplay);
          if (audio && shouldAutoplay) {
            audio.load();
            if (!window.appState || !window.appState.userPaused) {
              this.play();
            }
          }
        } else {
          // Update internal state (used for restart logic)
          this.readyState = newReadyState;
          this.networkState = newNetworkState;
        }
      }
    }

    // Router - using hash-based routing for file:// compatibility
    class Router {
      constructor(player, appState) {
        this.player = player;
        this.appState = appState;
        this.init();
      }
      
      init() {
        // Handle hash changes (browser back/forward)
        window.addEventListener('hashchange', () => {
          this.handleRoute();
        });
        
        // Handle initial load
        this.handleRoute();
      }
      
      navigate(path) {
        // Convert path format (/channel or /) to hash format (#channel or #)
        const hash = path === '/' ? '#' : '#' + path.slice(1);
        // Use replace to avoid adding to history if same hash
        if (window.location.hash !== hash) {
          window.location.hash = hash;
        } else {
          // If hash is already set, just handle the route
          this.handleRoute();
        }
      }
      
      handleRoute() {
        // Get channel from hash (remove #)
        const hash = window.location.hash.slice(1); // Remove #
        const channel = hash || '';
        
        if (this.appState) {
          const previousChannel = this.appState.currentChannel;
          
          // If navigating to empty hash, pause audio
          if (!channel) {
            const audio = document.getElementById('player');
            if (audio) {
              this.appState._isProgrammaticPause = true;
              audio.pause();
              this.appState.userPaused = true;
            }
            this.appState.currentChannel = '';
            // Stop tuning noise if playing
            if (this.player && this.player.tuningNoise) {
              this.player.tuningNoise.stop();
            }
          } else if (channel !== previousChannel) {
            // Changing to a different channel - always autoplay
            this.appState.userPaused = false;
            this.appState.currentChannel = channel;
            // Start tuning noise when switching channels
            if (this.player && this.player.tuningNoise && previousChannel) {
              this.player.tuningNoise.play();
            }
            // Trigger metadata fetch (watcher should also handle this, but ensure it happens)
            if (this.appState.fetchCurrentSong) {
              setTimeout(() => this.appState.fetchCurrentSong(), 100);
            }
          } else {
            // Same channel - keep current state
            this.appState.currentChannel = channel;
          }
        }
        
        if (channel) {
          document.title = channel + ' | Radio Guaka';
          // Always autoplay when changing to a different channel (userPaused was reset above)
          const shouldAutoplay = !this.appState || !this.appState.userPaused;
          this.player.setChannel(channel, this.appState, shouldAutoplay);
        } else {
          document.title = 'Radio Guaka';
          this.player.setChannel('', this.appState, false);
        }
      }
    }

    // Helper functions
    function volChange(delta) {
      const audio = document.getElementById('player');
      if (audio) {
        const newVolume = Math.max(0, Math.min(audio.volume + delta, 1));
        audio.volume = newVolume;
        // Update Alpine.js state to keep slider in sync
        if (window.appState) {
          window.appState.volume = newVolume;
        }
      }
    }

    function nextChannel(offset, appState, router) {
      // Get channels in visual order (as they appear on screen)
      const visualOrder = [];
      
      // First, add channels that don't belong to any section
      const sectionTags = typeof sections !== 'undefined' ? sections.flatMap(s => s.tags) : [];
      const otherChannels = Object.keys(channels)
        .filter(name => {
          const channel = channels[name];
          if (!channel.tags) return true;
          return !sectionTags.some(tag => channel.tags.indexOf(tag) > -1);
        })
        .sort();
      visualOrder.push(...otherChannels);
      
      // Then add channels from each section in order
      if (typeof sections !== 'undefined') {
        const sortedSections = [...sections].sort((a, b) => a.order - b.order);
        sortedSections.forEach(section => {
          const sectionChannels = Object.keys(channels)
            .filter(name => {
              const channel = channels[name];
              if (!channel.tags) return false;
              return section.tags.some(tag => channel.tags.indexOf(tag) > -1);
            })
            .sort();
          visualOrder.push(...sectionChannels);
        });
      }
      
      // Add empty string at beginning for "silence"
      visualOrder.unshift('');
      
      const currentChannel = appState.currentChannel || '';
      const currentIndex = visualOrder.indexOf(currentChannel);
      
      let newIndex = currentIndex + offset;
      
      if (newIndex >= visualOrder.length) {
        newIndex = 0;
      }
      if (newIndex < 0) {
        newIndex = visualOrder.length - 1;
      }
      
      const newChannel = visualOrder[newIndex];
      if (newChannel === '') {
        router.navigate('/');
      } else {
        router.navigate('/' + newChannel);
      }
    }

    // Alpine.js app
    function radioApp() {
      return {
        currentChannel: '',
        isPlaying: false,
        currentTime: 0,
        duration: 0,
        volume: 1,
        userPaused: false,
        _isProgrammaticPause: false,
        currentSong: null,
        currentSongError: null,
        isChatVisible: false, // Hidden by default on mobile, visible on desktop
        chatIframeReady: false,
        chatIframeCacheBuster: Date.now(), // Cache-busting timestamp set once per page load
        
        get chatIframeSrc() {
          // Add cache-busting parameter to ensure iframe always loads latest version on page refresh
          return `chatiframe1.html?t=${this.chatIframeCacheBuster}`;
        },
        
        // Build timestamp from buildtime.js (injected by Jekyll)
        // Falls back to current time locally (when Jekyll tag isn't processed)
        get buildDate() {
          if (typeof BUILD_TIME !== 'undefined' && /^\d/.test(BUILD_TIME)) {
            return BUILD_TIME;
          }
          const now = new Date();
          const year = now.getFullYear().toString().slice(-2);
          const month = (now.getMonth() + 1).toString().padStart(2, '0');
          const day = now.getDate().toString().padStart(2, '0');
          const hours = now.getHours().toString().padStart(2, '0');
          const minutes = now.getMinutes().toString().padStart(2, '0');
          return `${year}${month}${day} ${hours}:${minutes}`;
        },
        
        init() {
          // Make appState available globally for app.js
          window.appState = this;
          
          // Set chat visibility based on screen size
          if (window.innerWidth >= 769) {
            this.isChatVisible = true; // Show on desktop
          } else {
            this.isChatVisible = false; // Hide on mobile
          }
          
          // Update on resize
          window.addEventListener('resize', () => {
            if (window.innerWidth >= 769) {
              this.isChatVisible = true;
            }
          });
          
          console.log('Loaded channels:', Object.keys(channels).length);
          
          // Set up audio event listeners
          const setupAudioListeners = () => {
            const audio = document.getElementById('player');
            if (!audio) {
              setTimeout(setupAudioListeners, 50);
              return;
            }
            
            // Remove old listeners if they exist
            if (this._timeUpdateListener) {
              audio.removeEventListener('timeupdate', this._timeUpdateListener);
            }
            if (this._playListener) {
              audio.removeEventListener('play', this._playListener);
            }
            if (this._pauseListener) {
              audio.removeEventListener('pause', this._pauseListener);
            }
            
            // Update time display
            this._timeUpdateListener = () => {
              this.currentTime = audio.currentTime || 0;
            };
            audio.addEventListener('timeupdate', this._timeUpdateListener);
            
            // Update duration when metadata loads
            audio.addEventListener('loadedmetadata', () => {
              this.duration = audio.duration;
            });
            
            // Update duration when duration changes
            audio.addEventListener('durationchange', () => {
              this.duration = audio.duration;
            });
            
            // Update playing state
            this._playListener = () => {
              this.isPlaying = true;
              // Fetch metadata when playback starts
              if (this.currentChannel) {
                this.fetchCurrentSong();
              }
            };
            this._pauseListener = () => {
              this.isPlaying = false;
              // If pause was not programmatic (e.g., user paused via AirPods), set userPaused
              if (!this._isProgrammaticPause) {
                this.userPaused = true;
              }
              // Reset the flag after handling the pause event
              this._isProgrammaticPause = false;
            };
            audio.addEventListener('play', this._playListener);
            audio.addEventListener('pause', this._pauseListener);
            
            // Set initial volume
            audio.volume = this.volume;
            
            // Initial time update
            this.currentTime = audio.currentTime || 0;
          };
          
          setupAudioListeners();
          
          // Re-setup listeners when srcUrl changes (audio element might be recreated)
          this.$watch('srcUrl', () => {
            setTimeout(setupAudioListeners, 100);
          });
          
          // Wait for router to be initialized by app.js
          const checkRouter = () => {
            if (window.router) {
              window.router.handleRoute();
            } else {
              setTimeout(checkRouter, 50);
            }
          };
          checkRouter();
          
          // Set up metadata polling
          this.startMetadataPolling();
          
          // Set up Media Session API for lock screen/Bluetooth/car stereo controls
          this.setupMediaSession();
          
          // Watch for channel changes to restart polling
          this.$watch('currentChannel', () => {
            this.currentSong = null;
            this.currentSongError = null;
            this.startMetadataPolling();
          });
          
          // Watch for play/pause to start/stop polling
          this.$watch('isPlaying', () => {
            if (this.isPlaying) {
              this.startMetadataPolling();
            } else {
              this.stopMetadataPolling();
            }
          });
          
          // Watch for channel changes and notify chat iframe
          this.$watch('currentChannel', () => {
            this.sendChannelToChat();
            this.updateMediaSessionMetadata();
          });
          
          // Watch for song changes to update media session metadata (lock screen, car stereo)
          this.$watch('currentSong', () => {
            this.updateMediaSessionMetadata();
          });
          
          // Set up postMessage listener for chat
          window.addEventListener('message', (event) => {
            try {
              if (event.data.type === 'chatReady') {
                this.chatIframeReady = true;
                this.sendChannelToChat();
              } else if (event.data.type === 'tuneToChannel' && event.data.channel) {
                // User clicked a channel tag in chat - tune to that channel
                this.navigateTo('#' + event.data.channel);
              }
            } catch (e) {
              // Silently ignore chat errors - don't affect radio
              console.log('Chat message error (non-critical):', e);
            }
          });
        },
        
        toggleChat() {
          this.isChatVisible = !this.isChatVisible;
        },
        
        onChatIframeLoad() {
          // Iframe loaded, wait a bit then send channel
          setTimeout(() => {
            this.sendChannelToChat();
          }, 500);
        },
        
        sendChannelToChat() {
          try {
            const iframe = this.$refs.chatIframe;
            if (iframe && iframe.contentWindow) {
              iframe.contentWindow.postMessage({
                type: 'channelChange',
                channel: this.currentChannel ? this.currentChannel.replace(/_/g, ' ') : ''
              }, '*');
            }
          } catch (e) {
            // Silently ignore - chat errors shouldn't affect radio
            console.log('Chat communication error (non-critical):', e);
          }
        },
        
        sendSongToChat() {
          try {
            if (!this.currentSong) return;
            
            const iframe = this.$refs.chatIframe;
            if (iframe && iframe.contentWindow) {
              const songText = this.currentSong.artist && this.currentSong.title 
                ? `${this.currentSong.artist} - ${this.currentSong.title}`
                : (this.currentSong.title || '');
              
              if (songText) {
                iframe.contentWindow.postMessage({
                  type: 'addSongToMessage',
                  song: songText
                }, '*');
              }
            }
          } catch (e) {
            console.log('Chat communication error (non-critical):', e);
          }
        },
        
        setupMediaSession() {
          if (!('mediaSession' in navigator)) return;
          
          // Set action handlers for media controls (lock screen, Bluetooth, car stereo)
          navigator.mediaSession.setActionHandler('play', () => {
            this.togglePlay();
          });
          navigator.mediaSession.setActionHandler('pause', () => {
            this.togglePlay();
          });
          navigator.mediaSession.setActionHandler('previoustrack', () => {
            nextChannel(-1, this, window.router);
          });
          navigator.mediaSession.setActionHandler('nexttrack', () => {
            nextChannel(1, this, window.router);
          });
          navigator.mediaSession.setActionHandler('stop', () => {
            const audio = document.getElementById('player');
            if (audio) {
              audio.pause();
              audio.currentTime = 0;
            }
          });
        },
        
        updateMediaSessionMetadata() {
          if (!('mediaSession' in navigator)) return;
          
          const channelName = this.currentChannel 
            ? this.currentChannel.replace(/_/g, ' ') 
            : 'Radio Guaka';
          
          const artist = this.currentSong?.artist || '';
          const title = this.currentSong?.title || channelName;
          const album = this.currentSong?.album || 'Radio Guaka';
          
          navigator.mediaSession.metadata = new MediaMetadata({
            title: title,
            artist: artist,
            album: album,
            artwork: [
              { src: 'og-image.png', sizes: '512x512', type: 'image/png' }
            ]
          });
        },
        
        startMetadataPolling() {
          // Clear any existing interval
          this.stopMetadataPolling();
          
          // Only poll if we have a channel
          if (!this.currentChannel) {
            return;
          }
          
          // Fetch immediately (even if not playing yet)
          this.fetchCurrentSong();
          
          // Then poll every 12 seconds (only if playing)
          this._metadataInterval = setInterval(() => {
            if (this.currentChannel && this.isPlaying) {
              this.fetchCurrentSong();
            } else if (!this.currentChannel) {
              this.stopMetadataPolling();
            }
          }, 12000);
        },
        
        stopMetadataPolling() {
          if (this._metadataInterval) {
            clearInterval(this._metadataInterval);
            this._metadataInterval = null;
          }
        },
        
        togglePlay() {
          const audio = document.getElementById('player');
          if (!audio) return;
          
          if (audio.paused) {
            this.userPaused = false;
            audio.play();
          } else {
            this._isProgrammaticPause = true;
            this.userPaused = true;
            audio.pause();
          }
        },
        
        formatTime(seconds) {
          if (!isFinite(seconds) || isNaN(seconds)) return '0:00';
          const mins = Math.floor(seconds / 60);
          const secs = Math.floor(seconds % 60);
          return `${mins}:${secs.toString().padStart(2, '0')}`;
        },
        
        get hasValidDuration() {
          return isFinite(this.duration) && this.duration > 0;
        },
        
        setVolume(value) {
          const audio = document.getElementById('player');
          if (audio) {
            this.volume = parseFloat(value);
            audio.volume = this.volume;
          }
        },
        
        navigateTo(hash) {
          // Extract channel name from hash
          const channelName = hash === '#' ? '' : hash.slice(1);
          
          // If clicking the same channel, toggle play/pause instead of navigating
          if (channelName === this.currentChannel) {
            this.togglePlay();
            return;
          }
          
          // If changing to a different channel, reset userPaused and navigate
          this.userPaused = false;
          
          // Directly set hash - works with both file:// and http://
          // This will trigger hashchange event which calls router.handleRoute()
          if (window.location.hash !== hash) {
            window.location.hash = hash;
          } else {
            // If hash is already set, manually trigger route handling
            // Wait a bit to ensure router is ready, then handle route
            const handleRouteNow = () => {
              if (window.router) {
                window.router.handleRoute();
              } else {
                // Router not ready yet, try again
                setTimeout(handleRouteNow, 50);
              }
            };
            handleRouteNow();
          }
        },
        
        get sortedChannels() {
          if (typeof channels === 'undefined') {
            console.error('channels is not defined');
            return [];
          }
          return Object.keys(channels)
            .sort()
            .map(name => ({
              name: name,
              playing: name === this.currentChannel
            }));
        },
        
        get somaChannels() {
          if (typeof channels === 'undefined') {
            console.error('channels is not defined');
            return [];
          }
          return Object.keys(channels)
            .filter(name => {
              const channel = channels[name];
              return channel.tags && channel.tags.indexOf('soma') > -1;
            })
            .sort()
            .map(name => ({
              name: name,
              playing: name === this.currentChannel
            }));
        },
        
        get fipChannels() {
          if (typeof channels === 'undefined') {
            console.error('channels is not defined');
            return [];
          }
          return Object.keys(channels)
            .filter(name => {
              const channel = channels[name];
              return channel.tags && channel.tags.indexOf('fip') > -1;
            })
            .sort()
            .map(name => ({
              name: name,
              playing: name === this.currentChannel
            }));
        },
        
        get fluxFmChannels() {
          if (typeof channels === 'undefined') {
            console.error('channels is not defined');
            return [];
          }
          return Object.keys(channels)
            .filter(name => {
              const channel = channels[name];
              return channel.tags && channel.tags.indexOf('flux') > -1;
            })
            .sort()
            .map(name => ({
              name: name,
              playing: name === this.currentChannel
            }));
        },
        
        get otherStationsChannels() {
          if (typeof channels === 'undefined') {
            console.error('channels is not defined');
            return [];
          }
          return Object.keys(channels)
            .filter(name => {
              const channel = channels[name];
              return channel.tags && channel.tags.indexOf('other') > -1;
            })
            .sort()
            .map(name => ({
              name: name,
              playing: name === this.currentChannel
            }));
        },
        
        get paradiseChannels() {
          if (typeof channels === 'undefined') {
            console.error('channels is not defined');
            return [];
          }
          return Object.keys(channels)
            .filter(name => {
              const channel = channels[name];
              return channel.tags && channel.tags.indexOf('paradise') > -1;
            })
            .sort()
            .map(name => ({
              name: name,
              playing: name === this.currentChannel
            }));
        },
        
        get otherChannels() {
          if (typeof channels === 'undefined') {
            console.error('channels is not defined');
            return [];
          }
          // Channels that don't belong to any defined section
          const sectionTags = typeof sections !== 'undefined' ? sections.flatMap(s => s.tags) : [];
          return Object.keys(channels)
            .filter(name => {
              const channel = channels[name];
              if (!channel.tags) return true;
              // Check if channel belongs to any section
              return !sectionTags.some(tag => channel.tags.indexOf(tag) > -1);
            })
            .sort()
            .map(name => ({
              name: name,
              playing: name === this.currentChannel
            }));
        },
        
        get sortedSections() {
          if (typeof sections === 'undefined') {
            return [];
          }
          return [...sections].sort((a, b) => a.order - b.order);
        },
        
        getSectionChannels(section) {
          if (typeof channels === 'undefined' || typeof section === 'undefined') {
            return [];
          }
          return Object.keys(channels)
            .filter(name => {
              const channel = channels[name];
              if (!channel.tags) return false;
              // Channel must have at least one tag matching the section
              return section.tags.some(tag => channel.tags.indexOf(tag) > -1);
            })
            .sort()
            .map(name => ({
              name: name,
              playing: name === this.currentChannel
            }));
        },
        
        formatChannelName(channelName, sectionName) {
          // Special formatting for different sections
          if (sectionName === 'Radio Paradise') {
            return channelName === 'paradise' ? 'paradise' : channelName.replace(/^paradise_?/, '').replace(/_/g, ' ');
          }
          if (sectionName === 'Flux FM') {
            return channelName.replace(/^flux_fm_/, '').replace(/_/g, ' ');
          }
          // Default: replace underscores with spaces
          return channelName.replace(/_/g, ' ');
        },
        
        get currentChannelData() {
          if (!this.currentChannel) return null;
          
          const channel = channels[this.currentChannel];
          if (!channel) return null;
          
          const data = { ...channel, name: this.currentChannel };
          
          // Set SomaFM metadata if needed
          if (channel.tags && channel.tags.indexOf('soma') > -1) {
            data.site = 'https://somafm.com/';
          }
          
          // FIP channels already have site URLs in their channel data
          
          return data;
        },
        
        get srcUrl() {
          if (!this.currentChannel) return null;
          
          if (typeof channels === 'undefined') {
            console.error('channels is not defined');
            return null;
          }
          
          const channel = channels[this.currentChannel];
          if (!channel) return null;
          
          // SomaFM streams use a pattern
          if (channel.tags && channel.tags.indexOf('soma') > -1) {
            return 'https://ice.somafm.com/' + this.currentChannel;
          }
          
          return channel.url || null;
        },
        
        async fetchRadioParadiseMetadata() {
          if (!this.currentChannel) return null;
          
          const channel = channels[this.currentChannel];
          if (!channel) return null;
          
          // Map channel names to API chan parameter
          // Based on https://api.radioparadise.com/api/list_chan
          const chanMap = {
            'paradise': 0,        // Main Mix
            'paradise_mellow': 1, // Mellow Mix
            'paradise_rock': 2,   // RockIt!
            'paradise_global': 3, // Globalized (World)
            'paradise_beyond': 5, // Beyond...
            'paradise_serenity': 4, // Serenity (experimental)
            'paradise_2050': 0    // Radio 2050 (fallback to main)
          };
          
          const chan = chanMap[this.currentChannel];
          if (chan === undefined) return null;
          
          // Use the now_playing endpoint which returns a simple object
          const apiUrl = `https://api.radioparadise.com/api/now_playing?chan=${chan}`;
          
          // Radio Paradise API doesn't have CORS headers, so we need to use a proxy
          const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(apiUrl)}`;
          const proxyUrls = [proxyUrl];
          
          for (const proxyUrl of proxyUrls) {
            try {
              const response = await fetch(proxyUrl);
              if (response.ok) {
                const data = await response.json();
                if (data && data.artist && data.title) {
                  return {
                    artist: data.artist,
                    title: data.title,
                    album: data.album || ''
                  };
                }
              }
            } catch (error) {
              // Try next proxy
              continue;
            }
          }
          
          console.log('Radio Paradise metadata unavailable (all proxies failed)');
          return null;
        },
        
        async fetchSomaFMMetadata() {
          if (!this.currentChannel) return null;
          
          try {
            const response = await fetch('https://api.somafm.com/channels.json');
            if (!response.ok) {
              return null;
            }
            
            const data = await response.json();
            if (data && data.channels) {
              const channel = data.channels.find(ch => ch.id === this.currentChannel);
              if (channel) {
                // Try current_track first
                if (channel.current_track) {
                  const track = channel.current_track;
                  // If current_track is a string like "Artist - Title"
                  if (typeof track === 'string') {
                    const parts = track.split(' - ');
                    if (parts.length >= 2) {
                      return {
                        artist: parts[0].trim(),
                        title: parts.slice(1).join(' - ').trim(),
                        album: ''
                      };
                    } else if (parts.length === 1) {
                      return {
                        artist: '',
                        title: parts[0].trim(),
                        album: ''
                      };
                    }
                  }
                  // If current_track is an object
                  else if (track.title) {
                    return {
                      artist: track.artist || '',
                      title: track.title,
                      album: track.album || ''
                    };
                  }
                }
                // Try lastPlaying as fallback (can be string or object)
                if (channel.lastPlaying) {
                  const track = channel.lastPlaying;
                  
                  // If lastPlaying is a string like "Artist - Title"
                  if (typeof track === 'string') {
                    const parts = track.split(' - ');
                    if (parts.length >= 2) {
                      return {
                        artist: parts[0].trim(),
                        title: parts.slice(1).join(' - ').trim(),
                        album: ''
                      };
                    } else if (parts.length === 1) {
                      return {
                        artist: '',
                        title: parts[0].trim(),
                        album: ''
                      };
                    }
                  }
                  // If lastPlaying is an object
                  else if (track.title) {
                    return {
                      artist: track.artist || '',
                      title: track.title,
                      album: track.album || ''
                    };
                  }
                }
              }
            }
          } catch (error) {
            console.log('SomaFM metadata fetch error:', error);
          }
          return null;
        },
        
        async fetchFIPMetadata() {
          if (!this.currentChannel) return null;
          
          // Map channel names to station IDs
          // These IDs are used by the Radio France livemeta API
          const stationIdMap = {
            'fip': 7,
            'fip_jazz': 65,           // Jazz (Wayne Shorter, etc.)
            'fip_rock': 64,           // Rock (AC/DC, etc.)
            'fip_groove': 66,         // Groove/Funk/Soul
            'fip_reggae': 71,         // Reggae
            'fip_pop': 7,             // Fallback to main (no dedicated API)
            'fip_electro': 74,        // Electro
            'fip_monde': 69,          // World music
            'fip_nouveautes': 70,     // New releases
            'fip_metal': 77,          // Metal
            'fip_hiphop': 7,          // Fallback to main (no dedicated API)
            'fip_sacre_francais': 7   // Fallback to main (no dedicated API)
          };
          
          const stationId = stationIdMap[this.currentChannel];
          if (!stationId) return null;
          
          try {
            const response = await fetch(`https://api.radiofrance.fr/livemeta/pull/${stationId}`);
            if (!response.ok) return null;
            
            const data = await response.json();
            // The API returns steps as an object with UUIDs as keys, not an array
            if (data && data.steps && typeof data.steps === 'object') {
              const now = Math.floor(Date.now() / 1000); // Current time in Unix seconds
              const stepsArray = Object.values(data.steps);
              
              // Find the current track where now is between start and end (Unix timestamps)
              const currentTrack = stepsArray.find(step => {
                return step.start && step.end && now >= step.start && now < step.end;
              });
              
              if (currentTrack && currentTrack.title) {
                return {
                  artist: currentTrack.authors || currentTrack.performers || '',
                  title: currentTrack.title,
                  album: currentTrack.titreAlbum || ''
                };
              }
              
              // Fallback: if no current track found, return the most recent one
              if (stepsArray.length > 0) {
                // Sort by start time descending and get the most recent
                const sorted = stepsArray.sort((a, b) => (b.start || 0) - (a.start || 0));
                const mostRecent = sorted[0];
                if (mostRecent && mostRecent.title) {
                  return {
                    artist: mostRecent.authors || mostRecent.performers || '',
                    title: mostRecent.title,
                    album: mostRecent.titreAlbum || ''
                  };
                }
              }
            }
          } catch (error) {
            console.log('FIP metadata fetch error:', error);
          }
          return null;
        },
        
        async fetchFluxFMMetadata() {
          // Flux FM doesn't provide a JSON API endpoint like SomaFM
          // The metadata.fluxfm.de endpoint returns HTML, not JSON, and lacks CORS headers
          // Unlike SomaFM which has CORS-enabled JSON API, Flux FM metadata is not accessible
          return null;
        },
        
        async fetchSteroscenicMetadata() {
          if (!this.currentChannel) return null;
          
          // Map channel names to stream paths in the statistics API
          const streamPathMap = {
            'ambientsleepingpill': '/asp-s',
            'amambient': '/ama-s',
            'ambientmodern': '/mod-s'
          };
          
          const streamPath = streamPathMap[this.currentChannel];
          if (!streamPath) return null;
          
          // Stereoscenic API doesn't have CORS headers, so we use a proxy
          const apiUrl = 'https://radio.stereoscenic.com/statistics?json=1';
          const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(apiUrl)}`;
          
          try {
            const response = await fetch(proxyUrl);
            if (response.ok) {
              const data = await response.json();
              if (data && data.streams) {
                // Find the stream matching our channel
                const stream = data.streams.find(s => s.streampath === streamPath);
                if (stream && stream.songtitle) {
                  // songtitle format is "Artist - Title"
                  const parts = stream.songtitle.split(' - ');
                  if (parts.length >= 2) {
                    return {
                      artist: parts[0].trim(),
                      title: parts.slice(1).join(' - ').trim(),
                      album: ''
                    };
                  } else if (parts.length === 1) {
                    return {
                      artist: '',
                      title: parts[0].trim(),
                      album: ''
                    };
                  }
                }
              }
            }
          } catch (error) {
            console.log('Stereoscenic metadata fetch error:', error);
          }
          return null;
        },
        
        async fetchCurrentSong() {
          if (!this.currentChannel) {
            this.currentSong = null;
            return;
          }
          
          const channel = channels[this.currentChannel];
          if (!channel || !channel.tags) {
            this.currentSong = null;
            return;
          }
          
          let songData = null;
          
          // Check which API to use based on tags or channel name
          if (channel.tags.indexOf('paradise') > -1) {
            songData = await this.fetchRadioParadiseMetadata();
          } else if (channel.tags.indexOf('soma') > -1) {
            songData = await this.fetchSomaFMMetadata();
          } else if (channel.tags.indexOf('fip') > -1) {
            songData = await this.fetchFIPMetadata();
          } else if (channel.tags.indexOf('flux') > -1) {
            songData = await this.fetchFluxFMMetadata();
          } else if (['ambientsleepingpill', 'amambient', 'ambientmodern'].indexOf(this.currentChannel) > -1) {
            songData = await this.fetchSteroscenicMetadata();
          }
          
          this.currentSong = songData;
          this.currentSongError = songData ? null : 'No metadata available';
        }
      };
    }

    // Initialize app when DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
      // Wait for Alpine.js to initialize appState
      const initApp = () => {
        if (!window.appState) {
          setTimeout(initApp, 50);
          return;
        }
        
        // Initialize player
        const player = new RadioPlayer();
        window.radioPlayer = player;
        
        // Initialize router
        const router = new Router(player, window.appState);
        window.router = router;
        
        // Keyboard shortcuts
        document.body.addEventListener('keydown', (e) => {
          // Letter key to jump to channel (only if not typing in an input field)
          const activeElement = document.activeElement;
          const isInputField = activeElement && (
            activeElement.tagName === 'INPUT' ||
            activeElement.tagName === 'TEXTAREA' ||
            activeElement.isContentEditable
          );
          
          if (!isInputField && e.key && e.key.length === 1 && /[a-z]/i.test(e.key) && !e.ctrlKey && !e.altKey && !e.metaKey) {
            e.preventDefault();
            const char = e.key.toLowerCase();
            const channelKeys = Object.keys(channels).sort();
            const matchingChannels = channelKeys.filter(channel => channel[0] === char);
            
            if (matchingChannels.length === 0) {
              return;
            }
            
            const currentChannel = window.appState?.currentChannel || '';
            
            // If current channel starts with this letter, find the next one
            if (currentChannel && currentChannel[0] === char) {
              const currentIndex = matchingChannels.indexOf(currentChannel);
              if (currentIndex !== -1) {
                // Go to next channel, wrapping around if at the end
                const nextIndex = (currentIndex + 1) % matchingChannels.length;
                router.navigate('/' + matchingChannels[nextIndex]);
              } else {
                // Current channel not in list (shouldn't happen), go to first
                router.navigate('/' + matchingChannels[0]);
              }
            } else {
              // Current channel doesn't start with this letter, go to first match
              router.navigate('/' + matchingChannels[0]);
            }
            return;
          }
          
          switch (e.keyCode) {
            case 39: // Right arrow
              e.preventDefault();
              nextChannel(1, window.appState, router);
              break;
            case 37: // Left arrow
              e.preventDefault();
              nextChannel(-1, window.appState, router);
              break;
            case 38: // Up arrow
              e.preventDefault();
              volChange(0.1);
              break;
            case 40: // Down arrow
              e.preventDefault();
              volChange(-0.1);
              break;
            case 32: // Space - toggle play/pause
              e.preventDefault();
              if (window.appState) {
                window.appState.togglePlay();
              }
              break;
          }
        });
      };
      
      initApp();
    });
  </script>
</body>
</html>
