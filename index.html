<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Radio Guaka</title>
  <link rel="icon" type="image/png" href="favicon.ico">
  <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
  <style>
    html {
      font-size: 16px;
    }
    
    html, body {
      background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
      color: #e0e0e0;
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      font-size: 1rem;
      line-height: 1.6;
      height: 100vh;
      overflow: hidden;
    }

    .container {
      width: 100%;
      max-width: 100%;
      margin: 0 auto;
      padding: 0 clamp(8px, 1.5vw, 15px);
      box-sizing: border-box;
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    body {
      margin: 0;
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
      position: fixed;
      width: 100%;
    }

    header {
      padding: clamp(8px, 1.5vh, 15px) 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      background: rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(10px);
    }

    header .container {
      display: flex;
      flex-direction: column;
      gap: clamp(6px, 1vh, 10px);
    }
    
    header .container > div {
      display: flex;
      align-items: flex-start;
      gap: clamp(8px, 2vw, 12px);
    }

    header h2 {
      margin: 0;
      display: flex;
      align-items: center;
      gap: clamp(6px, 1.5vw, 10px);
      font-size: clamp(16px, 3.5vw, 20px);
      font-weight: 300;
      color: #fff;
    }

    header h2 .logo-icon {
      font-size: clamp(24px, 6vw, 36px);
      line-height: 1;
      display: inline-block;
    }

    header h2 strike {
      color: #666;
      text-decoration: line-through;
    }

    header audio {
      width: 100%;
      max-width: 600px;
      margin-top: clamp(4px, 1vh, 6px);
    }

    header > div > div {
      display: flex;
      align-items: center;
      gap: clamp(6px, 1.5vw, 10px);
      margin-top: clamp(6px, 1vh, 8px);
      font-size: clamp(11px, 2vw, 13px);
      color: #aaa;
      flex-wrap: wrap;
    }

    #networkState, #readyState {
      font-family: 'Monaco', 'Menlo', monospace;
      font-size: clamp(10px, 2vw, 12px);
      padding: clamp(3px, 0.5vw, 4px) clamp(6px, 1vw, 8px);
      background: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
    }

    article {
      padding: clamp(10px, 2vh, 20px) 0 clamp(40px, 6vh, 50px) 0; /* Extra bottom padding for fixed footer */
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      min-height: 0;
    }
    
    article .container {
      height: 100%;
      overflow: visible;
    }

    #channels {
      display: flex;
      flex-wrap: wrap;
      gap: clamp(4px, 1vw, 8px);
      margin-bottom: clamp(10px, 2vh, 20px);
    }

    /* Button styles - modernized */
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: clamp(4px, 0.8vh, 6px) clamp(8px, 1.5vw, 12px);
      font-size: clamp(11px, 2vw, 13px);
      font-weight: 500;
      line-height: 1.4;
      text-align: center;
      white-space: nowrap;
      cursor: pointer;
      user-select: none;
      border: none;
      border-radius: clamp(4px, 1vw, 6px);
      text-decoration: none;
      color: white;
      transition: all 0.2s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      min-height: 32px; /* Touch-friendly minimum height */
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }

    .btn:active {
      transform: translateY(0);
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
    }

    .btn-large {
      padding: clamp(5px, 1vh, 7px) clamp(10px, 2vw, 14px);
      font-size: clamp(11px, 2.2vw, 13px);
      border-radius: clamp(4px, 1vw, 6px);
      min-height: 32px; /* Touch-friendly minimum height */
    }

    .btn-primary {
      background: linear-gradient(135deg, #4a90e2 0%, #357abd 100%);
    }

    .btn-primary:hover {
      background: linear-gradient(135deg, #5aa0f2 0%, #458acd 100%);
    }

    .btn-success {
      background: linear-gradient(135deg, #52c41a 0%, #389e0d 100%);
    }

    .btn-success:hover {
      background: linear-gradient(135deg, #62d42a 0%, #48ae1d 100%);
    }

    .btn-danger {
      background: linear-gradient(135deg, #ff4d4f 0%, #cf1322 100%);
    }

    .btn-danger:hover {
      background: linear-gradient(135deg, #ff5d5f 0%, #df2332 100%);
    }

    .channel {
      text-transform: lowercase;
      letter-spacing: 0.5px;
    }

    h1 {
      margin: clamp(10px, 2vh, 15px) 0 clamp(8px, 1.5vh, 12px) 0;
      font-size: clamp(20px, 4.5vw, 28px);
      font-weight: 300;
      color: #fff;
      display: flex;
      align-items: center;
      gap: clamp(6px, 1.5vw, 10px);
    }

    h1 span {
      font-weight: 400;
      text-transform: lowercase;
      letter-spacing: 1px;
    }

    #metadata {
      margin-top: clamp(8px, 1.5vh, 12px);
      display: flex;
      align-items: center;
      gap: clamp(8px, 2vw, 12px);
      flex-wrap: wrap;
    }

    #metadata a {
      color: #ffd700;
      text-decoration: none;
      font-size: clamp(11px, 2vw, 13px);
      padding: clamp(4px, 0.8vh, 5px) clamp(8px, 1.5vw, 10px);
      background: rgba(255, 215, 0, 0.1);
      border-radius: clamp(3px, 0.8vw, 5px);
      transition: all 0.2s ease;
    }

    #metadata a:hover {
      background: rgba(255, 215, 0, 0.2);
      transform: translateY(-1px);
    }

    footer {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      padding: clamp(6px, 1.2vh, 10px) 0;
      background: rgba(20, 20, 20, 0.95);
      backdrop-filter: blur(10px);
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      z-index: 1000;
    }

    footer .container {
      padding: clamp(5px, 1vh, 7px) clamp(10px, 1.5vw, 15px);
    }

    footer p {
      margin: 0;
      font-size: clamp(11px, 2.5vw, 13px);
      line-height: 1.8;
      color: #aaa;
      text-align: center;
    }

    footer a {
      color: #ffd700;
      text-decoration: none;
      transition: color 0.2s ease;
    }

    footer a:hover {
      color: #ffed4e;
      text-decoration: underline;
    }

    footer strong {
      color: #fff;
      font-weight: 500;
    }


    /* Responsive */
    @media (max-width: 768px) {
      html {
        font-size: 15px;
      }
      
      header h2 {
        flex-direction: column;
        align-items: flex-start;
      }
      
      header h2 img {
        height: clamp(40px, 10vw, 50px);
      }
      
      #channels {
        justify-content: flex-start;
      }
      
      .btn {
        white-space: normal;
        word-break: break-word;
        hyphens: auto;
      }
    }
    
    @media (max-width: 480px) {
      html {
        font-size: 14px;
      }
      
      header {
        padding: clamp(6px, 1.2vh, 12px) 0;
      }
      
      header h2 {
        gap: 6px;
      }
      
      #channels {
        gap: 4px;
      }
      
      .btn-large {
        padding: 6px 10px;
        font-size: 13px;
      }
      
      h1 {
        font-size: 20px;
      }
      
      footer p {
        line-height: 1.5;
      }
    }
    
    @media (min-width: 1200px) {
      html {
        font-size: 18px;
      }
    }
    
    @media (min-width: 1600px) {
      html {
        font-size: 20px;
      }
    }

    /* Smooth transitions */
    * {
      transition: background-color 0.2s ease, color 0.2s ease;
    }
  </style>
</head>
<body x-data="radioApp()" x-init="init()">
  <div class="container">
    <!-- Player Header -->
    <header>
      <div class="container">
        <h2>
          <span class="logo-icon">üìª</span>
          radio guaka
        </h2>

        <div style="display: flex; align-items: flex-start; gap: clamp(8px, 2vw, 12px); flex-wrap: wrap;">
          <template x-if="srcUrl">
            <div style="flex: 1; min-width: 200px;">
              <audio preload="auto" id="player" controls :src="srcUrl" x-ref="audioPlayer">
              </audio>

              <div>
                <span>üì∂</span>
                <span id="networkState"></span>
                <span>‚è±</span>
                <span id="readyState"></span>
              </div>
            </div>
          </template>
          
          <a href="#" 
             @click.prevent="navigateTo('#')"
             class="btn"
             :class="currentChannel ? 'btn-danger' : 'btn-success'"
             id="stop"
             title="Stop"
             style="align-self: center;">
            ‚èπ Stop
          </a>
        </div>
      </div>
    </header>

    <!-- Main Content -->
    <article>
      <div class="container">
        <div id="channels" style="clear:both; width: 100%; max-width: 100%;">
          <h2 style="width: 100%; margin: clamp(10px, 2vh, 15px) 0 clamp(6px, 1.2vh, 10px) 0; font-size: clamp(13px, 2.5vw, 15px); font-weight: 300; color: #fff;">Other Stations</h2>
          
          <template x-for="channel in otherChannels" :key="channel.name">
            <a href="#"
               @click.prevent="navigateTo('#' + channel.name)"
               class="channel btn btn-large"
               :class="channel.playing ? 'btn-success' : 'btn-primary'">
              <span x-text="channel.name"></span>
            </a>
          </template>
          
          <h2 style="width: 100%; margin: clamp(10px, 2vh, 15px) 0 clamp(6px, 1.2vh, 10px) 0; font-size: clamp(13px, 2.5vw, 15px); font-weight: 300; color: #fff;">SomaFM</h2>
          
          <template x-for="channel in somaChannels" :key="channel.name">
            <a href="#"
               @click.prevent="navigateTo('#' + channel.name)"
               class="channel btn btn-large"
               :class="channel.playing ? 'btn-success' : 'btn-primary'">
              <span x-text="channel.name"></span>
            </a>
          </template>
          
          <h2 style="width: 100%; margin: clamp(10px, 2vh, 15px) 0 clamp(6px, 1.2vh, 10px) 0; font-size: clamp(13px, 2.5vw, 15px); font-weight: 300; color: #fff;">FIP</h2>
          
          <template x-for="channel in fipChannels" :key="channel.name">
            <a href="#"
               @click.prevent="navigateTo('#' + channel.name)"
               class="channel btn btn-large"
               :class="channel.playing ? 'btn-success' : 'btn-primary'">
              <span x-text="channel.name"></span>
            </a>
          </template>
        </div>

        <template x-if="currentChannelData">
          <div>
            <h1><span x-text="currentChannelData.name"></span></h1>
            <div id="metadata">
              <template x-if="currentChannelData.site">
                <a :href="currentChannelData.site" target="_blank" x-text="currentChannelData.site"></a>
              </template>
            </div>
          </div>
        </template>

      </div>
    </article>
    
    <!-- Footer -->
    <footer>
      <div class="container">
        <p>
          ‚å® shortcuts:
          Change volume ‚Üë ‚Üì
          Change channels ‚Üê ‚Üí
          or press first letter of the name. ‚èπ space bar.

          &mdash;
          <a target="_blank" href="https://github.com/guaka/radio-meteor/"><span>üì¶</span></a> <a target="_blank" href="https://github.com/guaka/radio">free software</a>
        </p>
      </div>
    </footer>
  </div>

  <script src="channels.js"></script>
  <script>
    // Network and ready state mappings
    const networkStates = {
      0: 'empty',
      1: 'idle',
      2: 'loading',
      3: 'no source'
    };

    const readyStates = {
      0: 'nothing',
      1: 'metadata',
      2: 'current',
      3: 'future',
      4: 'enough'
    };

    // Player class
    class RadioPlayer {
      constructor() {
        this.readyState = null;
        this.networkState = null;
        
        // Check status every 7 seconds
        setInterval(() => {
          if (this.audioTag()) {
            this.checkStatus();
          }
        }, 7000);
      }
      
      audioTag() {
        return document.getElementById('player');
      }
      
      play() {
        const audio = this.audioTag();
        if (audio) {
          audio.play();
        }
      }
      
      setChannel(channel, appState) {
        this.readyState = null;
        this.networkState = null;
        
        if (appState) {
          appState.currentChannel = channel;
        }
        
        // Get the expected source URL
        const expectedSrc = this.getExpectedSrc(channel);
        
        // Wait for audio element to be available (it's conditionally rendered by Alpine)
        const waitForAudioAndPlay = () => {
          const audio = this.audioTag();
          
          if (!audio) {
            // Audio element not rendered yet, wait a bit and try again
            if (expectedSrc) {
              setTimeout(waitForAudioAndPlay, 50);
            }
            return;
          }
          
          // Remove any existing event listeners to prevent duplicates
          const playWhenReady = () => {
            const playPromise = audio.play();
            if (playPromise !== undefined) {
              playPromise.catch(error => {
                // Autoplay was prevented - this is expected in some browsers
                // User can manually click play if needed
                console.log('Autoplay prevented:', error);
              });
            }
          };
          
          // Remove old listeners if they exist
          if (this._canPlayListener) {
            audio.removeEventListener('canplay', this._canPlayListener);
          }
          if (this._loadedDataListener) {
            audio.removeEventListener('loadeddata', this._loadedDataListener);
          }
          
          // Audio element exists, now set src and play
          audio.pause();
          
          if (expectedSrc) {
            // Set src directly for immediate playback (Alpine binding will sync)
            audio.src = expectedSrc;
            
            // Create event listeners for when audio is ready
            this._canPlayListener = playWhenReady;
            this._loadedDataListener = playWhenReady;
            
            // Add listeners for when audio is ready to play
            audio.addEventListener('canplay', this._canPlayListener, { once: true });
            audio.addEventListener('loadeddata', this._loadedDataListener, { once: true });
            
            // Load the audio
            audio.load();
            
            // Try to play immediately (user interaction should allow this)
            // If it fails, the event listeners will retry when ready
            setTimeout(() => {
              const playPromise = audio.play();
              if (playPromise !== undefined) {
                playPromise.catch(error => {
                  // Autoplay was prevented - event listeners will retry when ready
                  console.log('Immediate autoplay prevented, will retry when ready:', error);
                });
              }
            }, 50);
          } else {
            audio.src = '';
          }
        };
        
        // Start waiting for audio element
        waitForAudioAndPlay();
      }
      
      getExpectedSrc(channel) {
        if (!channel) return null;
        
        const channelData = channels[channel];
        if (!channelData) return null;
        
        // SomaFM streams use a pattern
        if (channelData.tags && channelData.tags.indexOf('soma') > -1) {
          return 'https://ice.somafm.com/' + channel;
        }
        
        return channelData.url || null;
      }
      
      checkStatus() {
        const audio = this.audioTag();
        if (!audio) return;
        
        const newNetworkState = audio.networkState;
        const newReadyState = audio.readyState;
        this.play();
        
        // Check if we need to restart (stuck state)
        if (this.readyState !== null &&
            newReadyState === this.readyState &&
            [0, 1].indexOf(newReadyState) > -1 &&
            newNetworkState !== 2) {
          console.log('Restart channel');
          this.readyState = null;
          this.networkState = null;
          const currentChannel = window.appState?.currentChannel || '';
          this.setChannel(currentChannel, window.appState);
          if (audio) {
            audio.load();
            this.play();
          }
        } else {
          // Update status display
          const readyStateEl = document.getElementById('readyState');
          const networkStateEl = document.getElementById('networkState');
          
          if (newReadyState !== null && readyStateEl) {
            readyStateEl.textContent = readyStates[newReadyState] || '';
          }
          if (newNetworkState !== null && networkStateEl) {
            networkStateEl.textContent = networkStates[newNetworkState] || '';
          }
          
          this.readyState = newReadyState;
          this.networkState = newNetworkState;
        }
      }
    }

    // Router - using hash-based routing for file:// compatibility
    class Router {
      constructor(player, appState) {
        this.player = player;
        this.appState = appState;
        this.init();
      }
      
      init() {
        // Handle hash changes (browser back/forward)
        window.addEventListener('hashchange', () => {
          this.handleRoute();
        });
        
        // Handle initial load
        this.handleRoute();
      }
      
      navigate(path) {
        // Convert path format (/channel or /) to hash format (#channel or #)
        const hash = path === '/' ? '#' : '#' + path.slice(1);
        // Use replace to avoid adding to history if same hash
        if (window.location.hash !== hash) {
          window.location.hash = hash;
        } else {
          // If hash is already set, just handle the route
          this.handleRoute();
        }
      }
      
      handleRoute() {
        // Get channel from hash (remove #)
        const hash = window.location.hash.slice(1); // Remove #
        const channel = hash || '';
        
        if (this.appState) {
          this.appState.currentChannel = channel;
        }
        
        if (channel) {
          document.title = channel + ' | Radio Guaka';
          this.player.setChannel(channel, this.appState);
        } else {
          document.title = 'Radio Guaka';
          this.player.setChannel('', this.appState);
        }
      }
    }

    // Helper functions
    function volChange(delta) {
      const audio = document.getElementById('player');
      if (audio) {
        audio.volume = Math.max(0, Math.min(audio.volume + delta, 1));
      }
    }

    function nextChannel(offset, appState, router) {
      const channelKeys = Object.keys(channels).sort();
      channelKeys.unshift(''); // Silence at beginning
      
      const currentIndex = channelKeys.indexOf(appState.currentChannel || '');
      let newIndex = currentIndex + offset;
      
      if (newIndex >= channelKeys.length) {
        newIndex = 0;
      }
      if (newIndex < 0) {
        newIndex = channelKeys.length - 1;
      }
      
      const newChannel = channelKeys[newIndex];
      if (newChannel === '') {
        router.navigate('/');
      } else {
        router.navigate('/' + newChannel);
      }
    }

    // Alpine.js app
    function radioApp() {
      return {
        currentChannel: '',
        
        init() {
          // Make appState available globally for app.js
          window.appState = this;
          
          console.log('Loaded channels:', Object.keys(channels).length);
          
          // Wait for router to be initialized by app.js
          const checkRouter = () => {
            if (window.router) {
              window.router.handleRoute();
            } else {
              setTimeout(checkRouter, 50);
            }
          };
          checkRouter();
        },
        
        navigateTo(hash) {
          // Directly set hash - works with both file:// and http://
          if (window.location.hash !== hash) {
            window.location.hash = hash;
          }
          // Router will handle the hashchange event
        },
        
        get sortedChannels() {
          if (typeof channels === 'undefined') {
            console.error('channels is not defined');
            return [];
          }
          return Object.keys(channels)
            .sort()
            .map(name => ({
              name: name,
              playing: name === this.currentChannel
            }));
        },
        
        get somaChannels() {
          if (typeof channels === 'undefined') {
            console.error('channels is not defined');
            return [];
          }
          return Object.keys(channels)
            .filter(name => {
              const channel = channels[name];
              return channel.tags && channel.tags.indexOf('soma') > -1;
            })
            .sort()
            .map(name => ({
              name: name,
              playing: name === this.currentChannel
            }));
        },
        
        get fipChannels() {
          if (typeof channels === 'undefined') {
            console.error('channels is not defined');
            return [];
          }
          return Object.keys(channels)
            .filter(name => {
              const channel = channels[name];
              return channel.tags && channel.tags.indexOf('fip') > -1;
            })
            .sort()
            .map(name => ({
              name: name,
              playing: name === this.currentChannel
            }));
        },
        
        get otherChannels() {
          if (typeof channels === 'undefined') {
            console.error('channels is not defined');
            return [];
          }
          return Object.keys(channels)
            .filter(name => {
              const channel = channels[name];
              return !channel.tags || (channel.tags.indexOf('soma') === -1 && channel.tags.indexOf('fip') === -1);
            })
            .sort()
            .map(name => ({
              name: name,
              playing: name === this.currentChannel
            }));
        },
        
        get currentChannelData() {
          if (!this.currentChannel) return null;
          
          const channel = channels[this.currentChannel];
          if (!channel) return null;
          
          const data = { ...channel, name: this.currentChannel };
          
          // Set SomaFM metadata if needed
          if (channel.tags && channel.tags.indexOf('soma') > -1) {
            data.site = 'https://somafm.com/';
          }
          
          // FIP channels already have site URLs in their channel data
          
          return data;
        },
        
        get srcUrl() {
          if (!this.currentChannel) return null;
          
          if (typeof channels === 'undefined') {
            console.error('channels is not defined');
            return null;
          }
          
          const channel = channels[this.currentChannel];
          if (!channel) return null;
          
          // SomaFM streams use a pattern
          if (channel.tags && channel.tags.indexOf('soma') > -1) {
            return 'https://ice.somafm.com/' + this.currentChannel;
          }
          
          return channel.url || null;
        }
      };
    }

    // Initialize app when DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
      // Wait for Alpine.js to initialize appState
      const initApp = () => {
        if (!window.appState) {
          setTimeout(initApp, 50);
          return;
        }
        
        // Initialize player
        const player = new RadioPlayer();
        window.radioPlayer = player;
        
        // Initialize router
        const router = new Router(player, window.appState);
        window.router = router;
        
        // Prevent scrolling with mouse wheel
        document.body.addEventListener('wheel', (e) => {
          e.preventDefault();
        }, { passive: false });
        
        // Prevent scrolling with touch
        document.body.addEventListener('touchmove', (e) => {
          e.preventDefault();
        }, { passive: false });
        
        // Keyboard shortcuts
        document.body.addEventListener('keydown', (e) => {
          // Letter key to jump to channel (only if not typing in an input field)
          const activeElement = document.activeElement;
          const isInputField = activeElement && (
            activeElement.tagName === 'INPUT' ||
            activeElement.tagName === 'TEXTAREA' ||
            activeElement.isContentEditable
          );
          
          if (!isInputField && e.key && e.key.length === 1 && /[a-z]/i.test(e.key) && !e.ctrlKey && !e.altKey && !e.metaKey) {
            e.preventDefault();
            const char = e.key.toLowerCase();
            const channelKeys = Object.keys(channels).sort();
            for (const channel of channelKeys) {
              if (channel[0] === char) {
                router.navigate('/' + channel);
                break;
              }
            }
            return;
          }
          
          switch (e.keyCode) {
            case 39: // Right arrow
              e.preventDefault();
              nextChannel(1, window.appState, router);
              break;
            case 37: // Left arrow
              e.preventDefault();
              nextChannel(-1, window.appState, router);
              break;
            case 38: // Up arrow
              e.preventDefault();
              volChange(0.1);
              break;
            case 40: // Down arrow
              e.preventDefault();
              volChange(-0.1);
              break;
            case 32: // Space
              e.preventDefault();
              router.navigate('/');
              break;
          }
        });
      };
      
      initApp();
    });
  </script>
</body>
</html>
