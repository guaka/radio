<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CHAT</title>
  <script src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js" defer></script>
  <script type="module">
    async function loadNDK() {
      try {
        // Import NDK from esm.sh - use latest version for bug fixes
        const NDKModule = await import('https://esm.sh/@nostr-dev-kit/ndk@latest');
        
        // NDK is the default export
        const NDK = NDKModule.default;
        
        // Get named exports - try multiple ways
        let NDKEvent = NDKModule.NDKEvent || NDK?.NDKEvent;
        let NDKUser = NDKModule.NDKUser || NDK?.NDKUser;
        let NDKPrivateKeySigner = NDKModule.NDKPrivateKeySigner || NDK?.NDKPrivateKeySigner;
        
        // Try importing from specific paths if not found
        if (!NDKEvent) {
          try {
            const eventModule = await import('https://esm.sh/@nostr-dev-kit/ndk@2.0.0/events');
            NDKEvent = eventModule.NDKEvent || eventModule.default;
          } catch (e) {
            // Fallback import failed
          }
        }
        
        if (!NDKUser) {
          try {
            const userModule = await import('https://esm.sh/@nostr-dev-kit/ndk@2.0.0/user');
            NDKUser = userModule.NDKUser || userModule.default;
          } catch (e) {
            // Fallback import failed
          }
        }
        
        if (!NDKPrivateKeySigner) {
          try {
            const signerModule = await import('https://esm.sh/@nostr-dev-kit/ndk@2.0.0/signers/private-key');
            NDKPrivateKeySigner = signerModule.NDKPrivateKeySigner || signerModule.default;
          } catch (e) {
            // Fallback import failed
          }
        }
        
        if (!NDK || typeof NDK !== 'function') {
          throw new Error('NDK class not found or not a constructor');
        }
        
        // Import crypto utilities for generatePrivateKey
        let generatePrivateKey = null;
        try {
          const cryptoUtils = await import('https://esm.sh/@noble/secp256k1@1.7.1');
          if (cryptoUtils && cryptoUtils.utils && cryptoUtils.utils.randomPrivateKey) {
            generatePrivateKey = () => {
              const bytes = cryptoUtils.utils.randomPrivateKey();
              return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
            };
          }
        } catch (e) {
          // Crypto utils import failed, will use fallback
        }
        
        // Fallback generatePrivateKey using Web Crypto API
        if (!generatePrivateKey) {
          generatePrivateKey = () => {
            const bytes = new Uint8Array(32);
            crypto.getRandomValues(bytes);
            return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
          };
        }
        
        // Expose NDK classes globally for compatibility with existing code
        window.NDK = NDK;
        window.NDKModule = {
          NDK: NDK,
          NDKEvent: NDKEvent,
          NDKUser: NDKUser,
          NDKPrivateKeySigner: NDKPrivateKeySigner,
          generatePrivateKey: generatePrivateKey
        };
        
        window.dispatchEvent(new CustomEvent('ndkReady', { 
          detail: { NDK: NDK, source: 'CDN (esm.sh)' } 
        }));
        
      } catch (error) {
        console.error('Failed to load NDK:', error);
        window.dispatchEvent(new CustomEvent('ndkError', { 
          detail: { error: error.message } 
        }));
      }
    }
    
    loadNDK();
  </script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap');
    
    * {
      box-sizing: border-box;
    }
    
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: 
        radial-gradient(circle at 20% 50%, rgba(0, 255, 255, 0.05) 0%, transparent 50%),
        radial-gradient(circle at 80% 80%, rgba(255, 0, 255, 0.05) 0%, transparent 50%),
        linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #0a0a0a 100%);
      background-attachment: fixed;
      background-color: #0a0a0a;
      color: #e0e0e0;
      /* Explicit font stack - no system font fallbacks that might trigger Japanese font probing */
      font-family: 'Share Tech Mono', 'Courier New', 'Courier', 'Lucida Console', 'Monaco', 'Consolas', monospace;
      font-size: 14px;
      line-height: 1.6;
    }
    
    /* Scan lines overlay */
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: repeating-linear-gradient(
        0deg,
        rgba(0, 255, 255, 0.02) 0px,
        rgba(0, 255, 255, 0.02) 1px,
        transparent 1px,
        transparent 2px
      );
      pointer-events: none;
      z-index: 1;
    }
    
    .chat-container {
      display: flex;
      flex-direction: column;
      height: 100vh;
      position: relative;
      z-index: 10;
    }
    
    .chat-header {
      padding: 12px 16px;
      border-bottom: 2px solid rgba(0, 255, 255, 0.4);
      background: 
        linear-gradient(180deg, rgba(20, 20, 30, 0.95) 0%, rgba(10, 10, 20, 0.98) 100%);
      backdrop-filter: blur(10px);
      box-shadow: 
        0 4px 20px rgba(0, 0, 0, 0.8),
        inset 0 1px 0 rgba(0, 255, 255, 0.3),
        0 0 40px rgba(0, 255, 255, 0.2);
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 8px;
    }
    
    .chat-title {
      font-size: 18px;
      font-weight: 700;
      font-family: 'Orbitron', 'Share Tech Mono', 'Courier New', 'Courier', 'Lucida Console', 'Monaco', 'Consolas', monospace;
      color: #00ffff;
      text-shadow: 
        0 0 10px rgba(0, 255, 255, 1),
        0 0 20px rgba(0, 255, 255, 0.8),
        0 0 30px rgba(0, 255, 255, 0.6);
      letter-spacing: 2px;
      text-transform: uppercase;
      margin: 0;
    }
    
    .current-channel {
      font-size: 12px;
      color: rgba(0, 255, 255, 0.7);
      text-shadow: 0 0 5px rgba(0, 255, 255, 0.5);
    }
    
    .chat-status {
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
    }
    
    .relay-status {
      display: flex;
      gap: 6px;
      align-items: center;
      font-size: 11px;
    }
    
    .relay-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #666;
      box-shadow: 0 0 4px rgba(255, 68, 68, 0.5);
    }
    
    .relay-dot.connected {
      background: #00ff7f;
      box-shadow: 0 0 8px rgba(0, 255, 127, 0.8);
    }
    
    .relay-dot.connecting {
      background: #ffd700;
      box-shadow: 0 0 8px rgba(255, 215, 0, 0.8);
      animation: pulse 2s ease-in-out infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    .auth-trigger {
      margin-left: 8px;
      width: 26px;
      height: 26px;
      border-radius: 4px;
      border: 1px solid rgba(0, 255, 255, 0.4);
      background: rgba(0, 255, 255, 0.08);
      color: #00ffff;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      transition: all 0.2s ease;
    }
    
    .auth-trigger:hover {
      background: rgba(0, 255, 255, 0.2);
      box-shadow: 0 0 8px rgba(0, 255, 255, 0.4);
    }
    
    .auth-current {
      margin: 10px 0 14px;
      font-size: 12px;
      color: rgba(0, 255, 255, 0.8);
      word-break: break-all;
    }
    .auth-current .key-value {
      color: #00ff7f;
      font-weight: 700;
    }
    .auth-input-row {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-top: 6px;
    }
    .auth-input-row input {
      flex: 1;
      padding: 10px;
      border-radius: 4px;
      border: 1px solid rgba(0, 255, 255, 0.3);
      background: rgba(0, 255, 255, 0.08);
      color: #00ffff;
      font-family: 'Courier New', monospace;
    }
    .auth-input-row button {
      padding: 10px 12px;
      border-radius: 4px;
      border: 1px solid rgba(0, 255, 255, 0.5);
      background: rgba(0, 255, 255, 0.15);
      color: #00ffff;
      cursor: pointer;
    }
    .auth-input-row button:hover {
      background: rgba(0, 255, 255, 0.25);
    }
    .auth-modal-close {
      position: absolute;
      top: 10px;
      right: 12px;
      background: transparent;
      border: none;
      color: #00ffff;
      font-size: 18px;
      cursor: pointer;
      padding: 4px;
      line-height: 1;
    }
    .auth-modal-close:hover {
      color: #ff00ff;
    }
    
    .chat-messages {
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 4px 6px;
      display: flex;
      flex-direction: column;
      gap: 1px;
      -webkit-overflow-scrolling: touch;
    }
    
    .message {
      padding: 2px 4px;
      background: rgba(15, 15, 30, 0.5);
      font-size: 12px;
      line-height: 1.3;
      overflow-wrap: break-word;
      word-break: break-word;
    }
    
    .message-new-user {
      margin-top: 8px;
    }
    
    .message-username {
      color: #00ffff;
      text-shadow: 0 0 4px rgba(0, 255, 255, 0.4);
      margin-right: 6px;
    }
    
    .message-time {
      font-size: 9px;
      color: rgba(255, 255, 255, 0.3);
      margin-right: 6px;
    }
    
    .message-channel {
      font-size: 10px;
      color: rgba(255, 200, 0, 0.7);
      margin-right: 6px;
      cursor: pointer;
    }
    
    .message-channel:hover {
      color: #ffd700;
      text-shadow: 0 0 6px rgba(255, 215, 0, 0.8);
    }
    
    .message-content {
      color: #e0e0e0;
      display: inline;
    }
    
    .message-actions {
      display: inline;
      margin-left: 8px;
      font-size: 10px;
    }
    
    .message-action {
      color: rgba(0, 255, 255, 0.5);
      cursor: pointer;
      padding: 1px 4px;
      border-radius: 2px;
    }
    
    .message-action:hover {
      color: #00ffff;
      background: rgba(0, 255, 255, 0.1);
    }
    
    .reaction-count {
      color: rgba(255, 255, 255, 0.5);
    }
    
    .chat-input-area {
      padding: 4px;
      background: 
        linear-gradient(180deg, rgba(10, 10, 20, 0.98) 0%, rgba(20, 20, 30, 0.95) 100%);
      backdrop-filter: blur(10px);
    }
    
    .chat-input {
      width: 100%;
      padding: 6px 8px;
      background: rgba(10, 10, 30, 0.8);
      border: 1px solid rgba(0, 255, 255, 0.3);
      border-radius: 2px;
      color: #e0e0e0;
      font-family: 'Share Tech Mono', 'Courier New', 'Courier', 'Lucida Console', 'Monaco', 'Consolas', monospace;
      font-size: 13px;
      resize: none;
      min-height: 44px;
      max-height: 120px;
      box-shadow: 
        inset 0 1px 2px rgba(0, 255, 255, 0.1),
        0 0 8px rgba(0, 255, 255, 0.1);
    }
    
    .chat-input:focus {
      outline: none;
      border-color: rgba(0, 255, 255, 0.6);
      box-shadow: 
        inset 0 1px 2px rgba(0, 255, 255, 0.2),
        0 0 15px rgba(0, 255, 255, 0.3);
    }
    
    
    .auth-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.9);
      display: flex;
      align-items: flex-start;
      justify-content: center;
      z-index: 1000;
      backdrop-filter: blur(5px);
      padding-top: 40px;
    }
    
    .auth-modal-content {
      background: 
        linear-gradient(135deg, rgba(20, 20, 40, 0.95) 0%, rgba(10, 10, 30, 0.98) 100%);
      border: 2px solid rgba(0, 255, 255, 0.4);
      border-radius: 8px;
      padding: 24px;
      max-width: 500px;
      width: 90%;
      box-shadow: 
        0 0 40px rgba(0, 255, 255, 0.3),
        inset 0 1px 2px rgba(0, 255, 255, 0.2);
    }
    
    .auth-modal h3 {
      color: #00ffff;
      text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
      margin-top: 0;
      font-family: 'Orbitron', 'Share Tech Mono', 'Courier New', 'Courier', 'Lucida Console', 'Monaco', 'Consolas', monospace;
      text-transform: uppercase;
      letter-spacing: 2px;
    }
    
    .auth-option {
      margin: 12px 0;
      padding: 12px;
      border: 1px solid rgba(0, 255, 255, 0.3);
      border-radius: 4px;
      background: rgba(0, 255, 255, 0.05);
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .auth-option:hover {
      border-color: rgba(0, 255, 255, 0.6);
      background: rgba(0, 255, 255, 0.1);
    }
    
    .auth-option-title {
      color: #00ffff;
      font-weight: 600;
      margin-bottom: 4px;
    }
    
    .auth-option-desc {
      font-size: 11px;
      color: rgba(255, 255, 255, 0.6);
    }
    
    .auth-input {
      width: 100%;
      padding: 8px;
      margin: 8px 0;
      background: rgba(10, 10, 30, 0.8);
      border: 1px solid rgba(0, 255, 255, 0.3);
      border-radius: 4px;
      color: #e0e0e0;
      font-family: 'Share Tech Mono', 'Courier New', 'Courier', 'Lucida Console', 'Monaco', 'Consolas', monospace;
      font-size: 12px;
    }
    
    .auth-button {
      padding: 8px 16px;
      margin: 4px;
      background: 
        linear-gradient(135deg, rgba(20, 20, 40, 0.9) 0%, rgba(10, 10, 30, 0.95) 100%);
      border: 2px solid rgba(0, 255, 127, 0.6);
      border-radius: 4px;
      color: #00ff7f;
      font-family: 'Share Tech Mono', 'Courier New', 'Courier', 'Lucida Console', 'Monaco', 'Consolas', monospace;
      font-size: 12px;
      cursor: pointer;
      text-transform: lowercase;
      letter-spacing: 1px;
    }
    
    .auth-button:hover {
      border-color: #00ff7f;
      box-shadow: 0 0 15px rgba(0, 255, 127, 0.4);
    }
    
    .error-message {
      padding: 12px;
      background: rgba(255, 68, 68, 0.1);
      border: 1px solid rgba(255, 68, 68, 0.3);
      border-radius: 4px;
      color: #ff4444;
      margin: 12px;
      font-size: 12px;
    }
    
    .loading {
      text-align: center;
      padding: 24px;
      color: rgba(0, 255, 255, 0.6);
      font-size: 12px;
    }
    
    /* Scrollbar styling */
    .chat-messages::-webkit-scrollbar {
      width: 8px;
    }
    
    .chat-messages::-webkit-scrollbar-track {
      background: rgba(10, 10, 30, 0.5);
    }
    
    .chat-messages::-webkit-scrollbar-thumb {
      background: rgba(0, 255, 255, 0.3);
      border-radius: 4px;
    }
    
    .chat-messages::-webkit-scrollbar-thumb:hover {
      background: rgba(0, 255, 255, 0.5);
    }
  </style>
</head>
<body x-data="chatApp()" x-init="init()">
  <div class="chat-container">
    <div class="chat-header">
      <div>
        <h2 class="chat-title">chat</h2>
      </div>
      <div class="chat-status">
        <div class="relay-status" x-show="relays.length > 0">
          <!-- Render exactly 2 dots (one for each relay) -->
          <template x-for="(relay, index) in relays.slice(0, 2)" :key="index">
            <div class="relay-dot" 
                 :class="relayStatus[relay]?.status || 'disconnected'"
                 :title="relay"></div>
          </template>
        </div>
        <button class="auth-trigger" @click="showAuthModal = true" title="Show key options">üîë</button>
      </div>
    </div>
    
    <div class="chat-messages" x-ref="messagesContainer">
      <template x-if="errorMessage">
        <div class="error-message" x-text="errorMessage"></div>
      </template>
      
      <template x-if="safeMessages.length === 0 && !isLoading">
        <div class="loading">No messages yet. Be the first to chat!</div>
      </template>
      
      <template x-if="isLoading">
        <div class="loading">Loading messages...</div>
      </template>
      
      <template x-for="(message, index) in safeMessages" :key="getMessageKey(message, index)">
        <div class="message" :class="{ 'message-new-user': !isSameUserAsPrevious(index) }"><span class="message-time" x-show="!isSameUserAsPrevious(index)" x-text="formatTime(message.created_at)"></span><span class="message-username" x-show="!isSameUserAsPrevious(index)" x-text="getUsername(message.pubkey)"></span><span class="message-channel" x-show="getMessageChannel(message)" x-text="getMessageChannel(message)" @click="tuneToChannel(getMessageChannel(message))"></span><span class="message-content" x-text="message.content"></span><span class="message-actions" x-show="isAuthenticated"><span class="message-action" @click="reactToMessage(message.id, 'üëç')" x-show="message.pubkey !== currentUserPubkey">üëç<span class="reaction-count" x-text="getReactionCount(message.id, 'üëç')"></span></span><span class="message-action" @click="deleteMessage(message.id)" x-show="message.pubkey === currentUserPubkey">√ó</span></span></div>
      </template>
    </div>
    
    <div class="chat-input-area">
      <textarea 
        x-model="messageInput"
        @keydown="handleKeyDown($event)"
        @focus="checkAuthOnFocus()"
        x-ref="chatInput"
        class="chat-input"
        placeholder="Type your message... (Enter to send, Shift+Enter for new line)"
        rows="1"
        autofocus></textarea>
    </div>
    
    <template x-if="showAuthModal">
      <div class="auth-modal" 
           @click.self="showAuthModal = false" 
           @keydown.escape="showAuthModal = false" 
           x-ref="authModal"
           x-effect="if (showAuthModal) { $nextTick(() => { $refs.authModal?.focus(); if (!useNip7Checkbox && !currentUserPrivateKey && $refs.nsecInput) { $refs.nsecInput.focus(); } }); }"
           tabindex="-1">
        <div class="auth-modal-content">
          <button class="auth-modal-close" @click="showAuthModal = false" aria-label="Close">√ó</button>
          <h3>Nostr keys</h3>
          
          <!-- Trigger detection check when modal opens -->
          <div x-effect="if (showAuthModal) { startExtensionPolling(); } else { stopExtensionPolling(); }"></div>
          
          <!-- NIP-07 checkbox (only if extension is available) -->
          <template x-if="hasExtension()">
            <div style="margin-bottom: 16px; padding: 12px; border: 1px solid rgba(0, 255, 255, 0.3); border-radius: 4px; background: rgba(0, 255, 255, 0.05);">
              <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; color: #00ffff;">
                <input 
                  type="checkbox" 
                  x-model="useNip7Checkbox"
                  @change="if (useNip7Checkbox) { authenticateWithExtension(); } else { usingNip07 = false; currentUserPrivateKey = null; currentUserNsec = null; currentUserPubkey = null; currentUserNpub = null; isAuthenticated = false; localStorage.removeItem('radio_guaka_chat_using_nip07'); }"
                  style="width: 18px; height: 18px; cursor: pointer;">
                <span style="font-size: 13px;">Use NIP-07 extension</span>
              </label>
            </div>
          </template>
          
          <!-- Unified key display -->
          <div class="auth-current">
            <template x-if="!useNip7Checkbox">
              <div style="margin-bottom: 12px;">
                <div style="margin-bottom: 6px; font-size: 12px; color: rgba(0, 255, 255, 0.8);">nsec:</div>
                <div class="auth-input-row">
                  <template x-if="usingNip07">
                    <input type="text" readonly value="(stored in extension - not available)" style="color: rgba(255, 255, 255, 0.5); font-style: italic;">
                  </template>
                  <template x-if="!usingNip07 && currentUserPrivateKey">
                    <input :type="showPrivateKey ? 'text' : 'password'" readonly :value="currentUserNsec || currentUserPrivateKey">
                  </template>
                  <template x-if="!usingNip07 && !currentUserPrivateKey">
                    <input 
                      type="text" 
                      x-model="manualKey" 
                      placeholder="nsec1..." 
                      @keydown.enter="authenticateWithKey()"
                      x-ref="nsecInput">
                  </template>
                  <template x-if="!usingNip07 && currentUserPrivateKey">
                    <button @click="showPrivateKey = !showPrivateKey" x-text="showPrivateKey ? 'hide' : 'show'"></button>
                  </template>
                </div>
              </div>
            </template>
            
            <div>
              <div style="margin-bottom: 6px; font-size: 12px; color: rgba(0, 255, 255, 0.8);">npub:</div>
              <div class="auth-input-row">
                <input type="text" readonly :value="currentUserNpub || ''" placeholder="npub not available" style="width: 100%;">
              </div>
            </div>
            
            <template x-if="currentUserNip05">
              <div style="margin-top: 12px;">
                <div style="margin-bottom: 6px; font-size: 12px; color: rgba(0, 255, 255, 0.8);">NIP-05:</div>
                <div class="auth-input-row">
                  <input type="text" readonly :value="currentUserNip05" style="width: 100%; color: #00ff88;">
                </div>
              </div>
            </template>
            
            <template x-if="!currentUserPrivateKey && !currentUserPubkey">
              <div style="margin-top: 12px;">
                <button @click="generateNewKey()" class="auth-button" style="width: 100%;">generate keys</button>
              </div>
            </template>
            
            
            <template x-if="currentUserPrivateKey || currentUserPubkey">
              <div style="margin-top: 12px;">
                <button @click="deleteKeys()" class="auth-button" style="width: 100%; background: rgba(255, 0, 100, 0.15); border-color: rgba(255, 0, 100, 0.5); color: #ff0064;">delete keys</button>
              </div>
            </template>
          </div>
        </div>
      </div>
    </template>
  </div>
  
  <script>
    /**
     * Radio Guaka Chat - Nostr-based chat component
     * 
     * AUTHENTICATION FLOW:
     * 1. Chat loads immediately in read-only mode (anyone can view messages)
     * 2. When user tries to post (focuses input or presses Enter):
     *    a. First, automatically try NIP-07 browser extension (nos2x, Alby, etc.)
     *    b. If NIP-07 succeeds: user is authenticated, can post
     *    c. If NIP-07 fails/unavailable: show modal with options:
     *       - Generate new key (creates anonymous keypair)
     *       - Import key (paste nsec/npub)
     *       - Retry extension (if extension detected)
     * 3. Keys are saved to localStorage for future sessions
     * 
     * This flow prioritizes:
     * - Immediate access to read chat
     * - Seamless auth for users with browser extensions
     * - Simple fallback for users without extensions
     */
    function chatApp() {
      return {
        // State
        ndk: null,
        messages: [],
        messageInput: '',
        isAuthenticated: false,
        currentUserPubkey: null,
        currentUserNpub: null,
        currentUserPrivateKey: null,
        currentUserNsec: null,
        currentUserNip05: null, // NIP-05 identifier (e.g. user@domain.com)
        usingNip07: false, // Track if we're using NIP-07 extension (no nsec available)
        currentChannel: '',
        relays: [],
        relayStatus: {},
        userProfiles: {},
        reactions: {},
        isLoading: true,
        isSending: false,
        showAuthModal: false,
        showManualAuth: false,
        showPrivateKey: false,
        useNip7Checkbox: false, // Checkbox state for NIP-07
        manualKey: '',
        errorMessage: '',
        isInIframe: window.parent !== window,
        extensionPollInterval: null, // Interval ID for polling extension
        extensionDetected: false, // Cached detection result
        parentNostrProxy: null, // Proxy to parent window's nostr (if in iframe)
        detectedNostrProvider: null, // The nostr provider we found (for use in setupSigner)
        
        // Method to check if extension is available (for template reactivity)
        hasExtension() {
          return this.extensionDetected || 
                 !!this.parentNostrProxy || 
                 (this.isInIframe && window.parent && window.parent.nostr && typeof window.parent.nostr.getPublicKey === 'function') ||
                 (window.nostr && typeof window.nostr.getPublicKey === 'function') ||
                 (window.webln && window.webln.nostr && typeof window.webln.nostr.getPublicKey === 'function');
        },
        
        // Ensure messages is always an array
        ensureMessagesArray() {
          if (!Array.isArray(this.messages)) {
            this.messages = [];
          }
        },
        
        // Deduplicate messages array in place
        deduplicateMessages() {
          this.ensureMessagesArray();
          const seen = new Set();
          const deduplicated = [];
          for (const msg of this.messages) {
            if (msg && msg.id && !seen.has(msg.id)) {
              seen.add(msg.id);
              deduplicated.push(msg);
            } else if (msg && !msg.id) {
              // Keep messages without IDs (shouldn't happen, but be safe)
              deduplicated.push(msg);
            }
          }
          this.messages = deduplicated;
        },
        
        // Get deduplicated messages array (computed property for template)
        get safeMessages() {
          try {
            this.ensureMessagesArray();
            // Deduplicate by ID, keeping the first occurrence
            const seen = new Set();
            const deduplicated = [];
            for (const msg of this.messages) {
              if (msg && msg.id && !seen.has(msg.id)) {
                seen.add(msg.id);
                deduplicated.push(msg);
              }
            }
            return deduplicated;
          } catch (e) {
            console.error('Error in safeMessages getter:', e);
            return [];
          }
        },
        
        // Get unique key for message (for Alpine.js x-for)
        getMessageKey(message, index) {
          if (message && message.id) {
            return String(message.id);
          }
          return 'msg-' + String(index);
        },
        
        // Initialize
        async init() {
          try {
            // Ensure messages is initialized as array
            this.ensureMessagesArray();
            
            // Load cached messages immediately for instant UI
            this.loadCachedMessages();
            
            // Parse URL parameters
            const params = new URLSearchParams(window.location.search);
            const hashtagParam = params.get('hashtag') || 'radioguaka';
            
            // Set up relays - using nomadwiki and trustroots community relays
            // IMPORTANT: We only use these 2 relays, never use relays from extension or user profile
            this.relays = [
              'wss://relay.nomadwiki.org',
              'wss://relay.trustroots.org'
            ];
            
            // Initialize relay status (only for the 2 relays)
            this.relayStatus = {};
            this.relays.forEach(relay => {
              this.relayStatus[relay] = { status: 'connecting' };
            });
            
            // Set up postMessage listener for parent communication
            if (this.isInIframe) {
              window.addEventListener('message', (event) => {
                try {
                  if (event.data.type === 'channelChange') {
                    this.currentChannel = event.data.channel || '';
                  } else if (event.data.type === 'addSongToMessage' && event.data.song) {
                    // Add song to message input (only if not already present)
                    const songText = event.data.song;
                    // Check if the song text is already in the input
                    if (!this.messageInput.includes(songText)) {
                      const separator = this.messageInput.trim() ? ' ' : '';
                      this.messageInput = this.messageInput + separator + songText;
                    }
                    // Focus the input
                    this.$nextTick(() => {
                      const input = this.$refs.chatInput;
                      if (input) {
                        input.focus();
                      }
                    });
                  } else if (event.data.type === 'likeSong' && event.data.song) {
                    // Immediately post the song with a like icon
                    const songText = event.data.song;
                    if (songText) {
                      // Set the message input with song + like icon
                      this.messageInput = `üëç ${songText}`;
                      // Immediately send the message (will handle auth if needed)
                      this.sendMessage();
                    }
                  }
                } catch (e) {
                  console.error('Error handling postMessage:', e);
                }
              });
              
              // Notify parent that chat is ready
              window.parent.postMessage({ type: 'chatReady' }, '*');
            }
            
            /*
             * AUTH FLOW:
             * 1. Chat is shown immediately in read-only mode
             * 2. When user tries to post (focus input or send):
             *    - First try NIP-07 extension automatically
             *    - If no NIP-07 or user denies: show modal to generate/import key
             * 3. Keys are saved to localStorage for future sessions
             */
            
            // Only load saved keys from storage (don't prompt or auto-auth)
            // User will be prompted when they try to post
            this.loadKeysFromStorage();
            
            // Wait for NDK to load
            if (window.NDKModule) {
              await this.initializeNDK();
            } else {
              window.addEventListener('ndkReady', () => {
                this.initializeNDK();
              });
              
              // Timeout if NDK doesn't load
              setTimeout(() => {
                if (!this.ndk) {
                  this.errorMessage = 'Failed to load NDK library. Chat unavailable.';
                  this.isLoading = false;
                }
              }, 5000);
            }
            
            // Focus the input field after initialization
            this.$nextTick(() => {
              setTimeout(() => {
                const input = this.$refs.chatInput;
                if (input) {
                  input.focus();
                }
              }, 500);
            });
          } catch (error) {
            console.error('Init error:', error);
            this.errorMessage = 'Failed to initialize chat: ' + error.message;
            this.isLoading = false;
          }
        },
        
        // Initialize NDK
        async initializeNDK() {
          try {
            if (!window.NDKModule) {
              throw new Error('NDK not available');
            }
            
            const NDKClass = window.NDKModule.NDK;
            
            if (typeof NDKClass !== 'function') {
              throw new Error('NDK class is not a constructor');
            }
            
            // Ensure relays are set
            if (!this.relays || this.relays.length === 0) {
              throw new Error('No relays configured');
            }
            
            // Try different initialization approaches for NDK v2.0.0
            // IMPORTANT: Only use our 2 configured relays, ignore any from extension/user
            try {
              // First try with explicitRelayUrls (this ensures only these relays are used)
              this.ndk = new NDKClass({
                explicitRelayUrls: this.relays
              });
            } catch (e) {
              // Try with 'relays' option name
              this.ndk = new NDKClass({
                relays: this.relays
              });
            }
            
            // Manually add relays if needed (for v2.0.0 compatibility)
            // Only add our configured relays, never add relays from extension
            if (this.ndk && this.ndk.addExplicitRelay) {
              this.relays.forEach(relayUrl => {
                try {
                  this.ndk.addExplicitRelay(relayUrl);
                } catch (e) {
                  // Could not add relay
                }
              });
            }
            
            await this.ndk.connect();
            
            // Intercept pool.addRelay to prevent unwanted relays from being added
            if (this.ndk.pool && this.ndk.pool.addRelay) {
              const originalAddRelay = this.ndk.pool.addRelay.bind(this.ndk.pool);
              this.ndk.pool.addRelay = async (relayUrlOrObject) => {
                // Handle both string URLs and Relay objects
                let relayUrl;
                if (typeof relayUrlOrObject === 'string') {
                  relayUrl = relayUrlOrObject;
                } else if (relayUrlOrObject && relayUrlOrObject.url) {
                  relayUrl = relayUrlOrObject.url;
                } else if (relayUrlOrObject && typeof relayUrlOrObject.toString === 'function') {
                  relayUrl = relayUrlOrObject.toString();
                } else {
                  // Unknown format, silently ignore
                  return undefined;
                }
                
                // Normalize relay URL (remove trailing slash)
                const normalizedUrl = relayUrl.replace(/\/$/, '');
                const normalizedRelays = this.relays.map(r => r.replace(/\/$/, ''));
                
                // Only allow our configured relays
                if (normalizedRelays.includes(normalizedUrl)) {
                  return await originalAddRelay(relayUrlOrObject);
                } else {
                  // Block any relay not in our configured list
                  // Silently return undefined - don't throw or reject
                  return undefined;
                }
              };
            }
            
            // Also intercept addExplicitRelay if it exists
            if (this.ndk.addExplicitRelay) {
              const originalAddExplicitRelay = this.ndk.addExplicitRelay.bind(this.ndk);
              this.ndk.addExplicitRelay = (relayUrlOrObject) => {
                // Handle both string URLs and Relay objects
                let relayUrl;
                if (typeof relayUrlOrObject === 'string') {
                  relayUrl = relayUrlOrObject;
                } else if (relayUrlOrObject && relayUrlOrObject.url) {
                  relayUrl = relayUrlOrObject.url;
                } else if (relayUrlOrObject && typeof relayUrlOrObject.toString === 'function') {
                  relayUrl = relayUrlOrObject.toString();
                } else {
                  // Unknown format, silently ignore
                  return undefined;
                }
                
                const normalizedUrl = relayUrl.replace(/\/$/, '');
                const normalizedRelays = this.relays.map(r => r.replace(/\/$/, ''));
                
                if (normalizedRelays.includes(normalizedUrl)) {
                  return originalAddExplicitRelay(relayUrlOrObject);
                } else {
                  // Silently ignore
                  return undefined;
                }
              };
            }
            
            // Ensure relays are properly set in the pool
            // Only use our 2 configured relays, ignore any others
            if (this.ndk.pool && (!this.ndk.pool.relays || this.ndk.pool.size === 0)) {
              // Manually add relays to pool if they're not there
              // Only add our configured relays
              for (const relayUrl of this.relays) {
                try {
                  if (this.ndk.pool.addRelay) {
                    await this.ndk.pool.addRelay(relayUrl);
                  } else if (this.ndk.addExplicitRelay) {
                    this.ndk.addExplicitRelay(relayUrl);
                  }
                } catch (e) {
                  // Could not add relay to pool
                }
              }
            }
            
            // Ensure we're not using any relays from extension or user profile
            // Remove any relays that aren't in our configured list
            this.cleanupRelays();
            
            // Set up a periodic cleanup to ensure no extension relays are added
            if (this._relayCleanupInterval) {
              clearInterval(this._relayCleanupInterval);
            }
            this._relayCleanupInterval = setInterval(() => {
              if (!document.hidden) {
                this.cleanupRelays();
              }
            }, 30000); // Check every 30 seconds
            
            document.addEventListener('visibilitychange', () => {
              if (!document.hidden) {
                this.cleanupRelays();
              }
            });
            
            // Set up relay status tracking (only for the 2 configured relays)
            if (this.ndk.pool) {
              this.ndk.pool.on('relay:connect', (relay) => {
                // Only track status for our configured relays
                const relayUrl = relay.url || relay;
                if (this.relays.includes(relayUrl)) {
                  this.relayStatus[relayUrl] = { status: 'connected' };
                }
              });
              
              this.ndk.pool.on('relay:disconnect', (relay) => {
                // Only track status for our configured relays
                const relayUrl = relay.url || relay;
                if (this.relays.includes(relayUrl)) {
                  this.relayStatus[relayUrl] = { status: 'disconnected' };
                }
              });
              
              // Also listen for 'connect' and 'disconnect' without 'relay:' prefix (NDK v2.x)
              this.ndk.pool.on('connect', (relay) => {
                const relayUrl = relay?.url || relay;
                if (this.relays.includes(relayUrl)) {
                  this.relayStatus[relayUrl] = { status: 'connected' };
                }
              });
              
              this.ndk.pool.on('disconnect', (relay) => {
                const relayUrl = relay?.url || relay;
                if (this.relays.includes(relayUrl)) {
                  this.relayStatus[relayUrl] = { status: 'disconnected' };
                }
              });
            }
            
            // Wait a bit for relays to be fully connected before subscribing
            await new Promise(resolve => setTimeout(resolve, 1500));
            
            // Check actual relay connection status after waiting
            this.updateRelayStatus();
            
            // Start subscriptions
            this.startSubscriptions();
            
            // Periodically update relay status (every 30 seconds as fallback)
            setInterval(() => this.updateRelayStatus(), 30000);
            
            // Also try a direct fetch as fallback after a delay
            setTimeout(() => this.fetchPastMessages(), 3000);
            
            // If authenticated, set up signer
            if (this.currentUserPrivateKey) {
              await this.setupSigner();
            }
            
            // Recompute npub if we have a pubkey but npub wasn't set (NDK might not have been ready before)
            if (this.currentUserPubkey && !this.currentUserNpub) {
              this.setUserPubkey(this.currentUserPubkey);
            }
            
          } catch (error) {
            console.error('NDK init error:', error);
            this.errorMessage = 'Failed to connect to relays: ' + error.message;
            this.isLoading = false;
          }
        },
        
        // Start subscriptions
        startSubscriptions() {
          try {
            if (!this.ndk) return;
            
            // Subscribe to kind 1 messages with #radioguaka tag
            const messageFilter = { 
              kinds: [1],
              '#t': ['radioguaka'],
              limit: 100
            };
            
            const subscription = this.ndk.subscribe(messageFilter, { closeOnEose: false });
            
            // Attach event handlers using the correct NDK API
            subscription.on('event', (event) => {
              try {
                this.handleMessageEvent(event);
                // Receiving events means relays are connected - update status
                this.markRelaysConnected();
              } catch (e) {
                console.error('Error handling message event:', e);
              }
            });
            
            subscription.on('eose', () => {
              this.isLoading = false;
              // End of stored events means relays responded - they're connected
              this.markRelaysConnected();
            });
            
            // Also listen for events via the NDK events iterator pattern (alternative API)
            (async () => {
              try {
                // Some NDK versions use async iterator
                if (subscription[Symbol.asyncIterator]) {
                  for await (const event of subscription) {
                    try {
                      this.handleMessageEvent(event);
                    } catch (e) {
                      console.error('Error handling async message event:', e);
                    }
                  }
                }
              } catch (e) {
                // Async iterator not supported, that's fine - we're using .on() handlers
              }
            })();
            
            // Subscribe to profiles (kind 0) for usernames of message authors
            const profileSubscription = this.ndk.subscribe(
              { kinds: [0] },
              { closeOnEose: true }
            );
            
            profileSubscription.on('event', (event) => {
              try {
                this.handleProfileEvent(event);
              } catch (e) {
                console.error('Error handling profile event:', e);
              }
            });
            
            // Subscribe to reactions (kind 7)
            const reactionSubscription = this.ndk.subscribe(
              { kinds: [7] },
              { closeOnEose: false }
            );
            
            reactionSubscription.on('event', (event) => {
              try {
                this.handleReactionEvent(event);
              } catch (e) {
                console.error('Error handling reaction event:', e);
              }
            });
            
            // Subscribe to deletions (kind 5)
            const deletionSubscription = this.ndk.subscribe(
              { kinds: [5] },
              { closeOnEose: false }
            );
            
            deletionSubscription.on('event', (event) => {
              try {
                this.handleDeletionEvent(event);
              } catch (e) {
                console.error('Error handling deletion event:', e);
              }
            });
            
          } catch (error) {
            console.error('Subscription error:', error);
            this.errorMessage = 'Failed to subscribe to messages: ' + error.message;
            this.isLoading = false;
          }
        },
        
        // Handle message events
        handleMessageEvent(event) {
          // Ensure messages is an array
          this.ensureMessagesArray();
          
          // Validate event has required fields
          if (!event || !event.id) {
            console.warn('Invalid message event: missing id', event);
            return;
          }
          
          // Check if message already exists (including optimistic ones)
          const existingIndex = this.messages.findIndex(m => m && m.id === event.id);
          if (existingIndex !== -1) {
            // Update existing optimistic message with real data from relay
            if (this.messages[existingIndex].optimistic) {
              this.messages[existingIndex] = {
                id: event.id,
                pubkey: event.pubkey,
                content: event.content,
                created_at: event.created_at,
                tags: event.tags
              };
            }
            return;
          }
          
          // Check if message has #radioguaka tag
          const tags = event.tags || [];
          const hasTag = tags.some(tag => tag[0] === 't' && tag[1] === 'radioguaka');
          
          if (!hasTag) return;
          
          const message = {
            id: event.id,
            pubkey: event.pubkey,
            content: event.content,
            created_at: event.created_at,
            tags: event.tags
          };
          
          // Insert sorted by timestamp
          const insertIndex = this.messages.findIndex(m => m && m.created_at > event.created_at);
          if (insertIndex === -1) {
            this.messages.push(message);
          } else {
            this.messages.splice(insertIndex, 0, message);
          }
          
          // Keep only last 200 messages in memory
          if (this.messages.length > 200) {
            this.messages = this.messages.slice(-200);
          }
          
          // Deduplicate before saving
          this.deduplicateMessages();
          
          // Save to localStorage cache
          this.saveCachedMessages();
          
          // Auto-scroll to bottom
          this.$nextTick(() => {
            const container = this.$refs.messagesContainer;
            if (container) {
              container.scrollTop = container.scrollHeight;
            }
          });
        },
        
        // Handle profile events
        handleProfileEvent(event) {
          try {
            const profile = JSON.parse(event.content);
            this.userProfiles[event.pubkey] = {
              name: profile.name || profile.display_name || 'Anonymous',
              picture: profile.picture || '',
              nip05: profile.nip05 || null
            };
            
            // If this is the current user's profile, update their NIP-05
            if (this.currentUserPubkey && event.pubkey === this.currentUserPubkey) {
              this.currentUserNip05 = profile.nip05 || null;
            }
          } catch (e) {
            console.error('Error parsing profile:', e);
          }
        },
        
        // Handle reaction events
        handleReactionEvent(event) {
          try {
            const tags = event.tags || [];
            const eventTag = tags.find(tag => tag[0] === 'e');
            if (!eventTag) return;
            
            const eventId = eventTag[1];
            const content = event.content;
            
            if (!this.reactions[eventId]) {
              this.reactions[eventId] = {};
            }
            
            if (!this.reactions[eventId][content]) {
              this.reactions[eventId][content] = [];
            }
            
            if (!this.reactions[eventId][content].includes(event.pubkey)) {
              this.reactions[eventId][content].push(event.pubkey);
            }
          } catch (e) {
            console.error('Error handling reaction:', e);
          }
        },
        
        // Handle deletion events (kind 5)
        handleDeletionEvent(event) {
          try {
            // Ensure messages is an array
            this.ensureMessagesArray();
            
            const tags = event.tags || [];
            // Get all 'e' tags (deleted event IDs)
            const deletedIds = tags
              .filter(tag => tag[0] === 'e')
              .map(tag => tag[1]);
            
            if (deletedIds.length === 0) return;
            
            // Only delete messages that were authored by the deletion event's author
            const originalCount = this.messages.length;
            this.messages = this.messages.filter(m => {
              if (m && deletedIds.includes(m.id)) {
                // Verify the deletion is from the message author
                return m.pubkey !== event.pubkey;
              }
              return true;
            });
            
            // Update cache if messages were removed
            if (this.messages.length < originalCount) {
              this.saveCachedMessages();
            }
          } catch (e) {
            console.error('Error handling deletion:', e);
          }
        },
        
        // Get username
        getUsername(pubkey) {
          if (this.userProfiles[pubkey]) {
            return this.userProfiles[pubkey].name;
          }
          // Convert hex pubkey to npub format and abbreviate
          const npub = this.hexToNpub(pubkey);
          return npub.substring(0, 12) + '...';
        },
        
        // Check if message is from the same user as previous message
        isSameUserAsPrevious(index) {
          this.ensureMessagesArray();
          if (index === 0 || !Array.isArray(this.messages)) return false;
          if (index >= this.messages.length || index - 1 < 0) return false;
          const current = this.messages[index];
          const previous = this.messages[index - 1];
          if (!current || !previous) return false;
          return current.pubkey === previous.pubkey;
        },
        
        // Convert hex pubkey to npub (bech32 encoding)
        hexToNpub(hex) {
          try {
            const ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
            const CHARSET_MAP = {};
            for (let i = 0; i < ALPHABET.length; i++) {
              CHARSET_MAP[ALPHABET[i]] = i;
            }
            
            // Convert hex to bytes
            const bytes = [];
            for (let i = 0; i < hex.length; i += 2) {
              bytes.push(parseInt(hex.substr(i, 2), 16));
            }
            
            // Convert 8-bit bytes to 5-bit groups
            const data = [];
            let value = 0;
            let bits = 0;
            for (const byte of bytes) {
              value = (value << 8) | byte;
              bits += 8;
              while (bits >= 5) {
                bits -= 5;
                data.push((value >> bits) & 31);
              }
            }
            if (bits > 0) {
              data.push((value << (5 - bits)) & 31);
            }
            
            // Create checksum
            const hrp = 'npub';
            const values = data;
            
            function polymod(values) {
              const GENERATOR = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];
              let chk = 1;
              for (const v of values) {
                const top = chk >> 25;
                chk = ((chk & 0x1ffffff) << 5) ^ v;
                for (let i = 0; i < 5; i++) {
                  if ((top >> i) & 1) {
                    chk ^= GENERATOR[i];
                  }
                }
              }
              return chk;
            }
            
            function hrpExpand(hrp) {
              const ret = [];
              for (let i = 0; i < hrp.length; i++) {
                ret.push(hrp.charCodeAt(i) >> 5);
              }
              ret.push(0);
              for (let i = 0; i < hrp.length; i++) {
                ret.push(hrp.charCodeAt(i) & 31);
              }
              return ret;
            }
            
            const checksumInput = hrpExpand(hrp).concat(values).concat([0, 0, 0, 0, 0, 0]);
            const mod = polymod(checksumInput) ^ 0x2bc830a3; // bech32m constant
            const checksum = [];
            for (let i = 0; i < 6; i++) {
              checksum.push((mod >> (5 * (5 - i))) & 31);
            }
            
            // Encode
            let result = hrp + '1';
            for (const d of values.concat(checksum)) {
              result += ALPHABET[d];
            }
            
            return result;
          } catch (e) {
            // Fallback to hex if encoding fails
            return hex.substring(0, 8) + '...';
          }
        },
        
        // Get reaction count
        getReactionCount(eventId, emoji) {
          if (!this.reactions[eventId] || !this.reactions[eventId][emoji]) {
            return '';
          }
          const count = this.reactions[eventId][emoji].length;
          return count > 0 ? count : '';
        },
        
        // Get channel from message tags
        getMessageChannel(message) {
          if (!message.tags) return '';
          const channelTag = message.tags.find(tag => tag[0] === 'channel');
          return channelTag ? channelTag[1] : '';
        },
        
        // Tune to a channel (tell parent window to switch)
        tuneToChannel(channel) {
          if (!channel) return;
          try {
            // Convert spaces back to underscores (channel names use underscores)
            const channelId = channel.replace(/ /g, '_');
            // Send message to parent to change channel
            window.parent.postMessage({
              type: 'tuneToChannel',
              channel: channelId
            }, '*');
          } catch (e) {
            // Ignore tune request errors
          }
        },
        
        // Format time
        formatTime(timestamp) {
          const date = new Date(timestamp * 1000);
          const hours = date.getHours().toString().padStart(2, '0');
          const minutes = date.getMinutes().toString().padStart(2, '0');
          return `${hours}:${minutes}`;
        },
        
        // Escape HTML
        escapeHtml(text) {
          const div = document.createElement('div');
          div.textContent = text;
          return div.innerHTML;
        },
        
        // Check auth when user focuses input
        // Flow: silently try NIP-07; no modal here to avoid surprise popups
        async checkAuthOnFocus() {
          if (this.isAuthenticated) return;
          
          // Small delay to let user see they can type
          await new Promise(r => setTimeout(r, 300));
          if (this.isAuthenticated) return;
          
          // Try NIP-07 extension first (silently)
          if (this.detectNostrExtension()) {
            console.log('Trying NIP-07 extension on focus...');
            const success = await this.authenticateWithExtension();
            if (success) {
              console.log('NIP-07 auth successful');
              return;
            }
            console.log('NIP-07 auth failed or denied');
          }
          // If still unauthenticated, do nothing here. Modal will appear on send or via header icon.
        },
        
        // Handle keyboard input
        handleKeyDown(event) {
          // Shift+Enter = new line (allow default behavior)
          if (event.key === 'Enter' && event.shiftKey) {
            return; // Allow default behavior (new line)
          }
          
          // Enter (without Shift) = send message
          if (event.key === 'Enter' && !event.shiftKey) {
            event.preventDefault();
            this.sendMessage();
          }
        },
        
        // Clean up relays - remove any that aren't in our configured list
        cleanupRelays() {
          if (!this.ndk || !this.ndk.pool || !this.ndk.pool.relays) return;
          
          // Normalize configured relays (remove trailing slashes)
          const normalizedConfiguredRelays = new Set(
            this.relays.map(r => r.replace(/\/$/, ''))
          );
          const relaysToRemove = [];
          
          // Check all relays in the pool
          if (this.ndk.pool.relays instanceof Map) {
            for (const [url, relay] of this.ndk.pool.relays) {
              const normalizedUrl = url.replace(/\/$/, '');
              if (!normalizedConfiguredRelays.has(normalizedUrl)) {
                relaysToRemove.push(url);
              }
            }
          } else if (Array.isArray(this.ndk.pool.relays)) {
            for (const relay of this.ndk.pool.relays) {
              const url = relay.url || relay;
              const normalizedUrl = url.replace(/\/$/, '');
              if (!normalizedConfiguredRelays.has(normalizedUrl)) {
                relaysToRemove.push(url);
              }
            }
          }
          
          // Remove any relays not in our configured list
          for (const url of relaysToRemove) {
            try {
              if (this.ndk.pool.removeRelay) {
                this.ndk.pool.removeRelay(url);
              }
            } catch (e) {
              // Ignore removal errors
            }
          }
          
          // Ensure our configured relays are in the pool
          for (const relayUrl of this.relays) {
            try {
              let relayExists = false;
              if (this.ndk.pool.relays instanceof Map) {
                relayExists = this.ndk.pool.relays.has(relayUrl);
              } else if (Array.isArray(this.ndk.pool.relays)) {
                relayExists = this.ndk.pool.relays.some(r => (r.url || r) === relayUrl);
              }
              
              if (!relayExists) {
                if (this.ndk.pool.addRelay) {
                  this.ndk.pool.addRelay(relayUrl).catch(() => {});
                } else if (this.ndk.addExplicitRelay) {
                  this.ndk.addExplicitRelay(relayUrl);
                }
              }
            } catch (e) {
              // Could not add relay
            }
          }
        },
        
        // Store WebSocket connections to our relays
        relayWebSockets: {},
        
        // Get or create WebSocket connection to a relay
        async getRelayWebSocket(relayUrl) {
          // Check if we already have a connected WebSocket
          if (this.relayWebSockets[relayUrl] && 
              this.relayWebSockets[relayUrl].readyState === WebSocket.OPEN) {
            return this.relayWebSockets[relayUrl];
          }
          
          // Create a new WebSocket connection
          return new Promise((resolve, reject) => {
            try {
              const ws = new WebSocket(relayUrl);
              
              ws.onopen = () => {
                this.relayWebSockets[relayUrl] = ws;
                resolve(ws);
              };
              
              ws.onerror = (error) => {
                reject(new Error(`WebSocket error for ${relayUrl}`));
              };
              
              // Timeout after 5 seconds
              setTimeout(() => {
                if (ws.readyState !== WebSocket.OPEN) {
                  ws.close();
                  reject(new Error(`WebSocket connection timeout for ${relayUrl}`));
                }
              }, 5000);
              
            } catch (e) {
              reject(e);
            }
          });
        },
        
        // Publish event directly via WebSocket to a relay
        async publishToRelayViaWebSocket(relayUrl, plainEvent) {
          return new Promise(async (resolve, reject) => {
            try {
              const ws = await this.getRelayWebSocket(relayUrl);
              
              // Listen for OK response
              const messageHandler = (msg) => {
                try {
                  const data = JSON.parse(msg.data);
                  // ["OK", <event_id>, <true|false>, <message>]
                  if (data[0] === 'OK' && data[1] === plainEvent.id) {
                    ws.removeEventListener('message', messageHandler);
                    if (data[2]) {
                      resolve({ success: true, relay: relayUrl });
                    } else {
                      reject(new Error(`Relay rejected event: ${data[3] || 'unknown reason'}`));
                    }
                  }
                } catch (e) {
                  // Not JSON or not relevant message, ignore
                }
              };
              
              ws.addEventListener('message', messageHandler);
              
              // Send the event
              const eventMessage = JSON.stringify(['EVENT', plainEvent]);
              ws.send(eventMessage);
              
              // Timeout after 10 seconds
              setTimeout(() => {
                ws.removeEventListener('message', messageHandler);
                reject(new Error(`Publish timeout for ${relayUrl}`));
              }, 10000);
              
            } catch (e) {
              reject(e);
            }
          });
        },
        
        // Publish event to only our configured relays (ignore extension/user relays)
        async publishToOurRelays(event) {
          // Convert NDKEvent to plain event object for publishing
          const plainEvent = {
            id: event.id,
            kind: event.kind,
            created_at: event.created_at,
            tags: event.tags || [],
            content: event.content || '',
            sig: event.sig,
            pubkey: event.pubkey
          };
          
          // Publish directly to each of our configured relays via WebSocket
          // This completely bypasses NDK's relay management
          const publishPromises = this.relays.map(relayUrl => 
            this.publishToRelayViaWebSocket(relayUrl, plainEvent)
              .catch(e => ({ error: e.message, relay: relayUrl }))
          );
          
          // Wait for all publish attempts
          const results = await Promise.allSettled(publishPromises);
          
          // Count successes
          const successes = results.filter(r => 
            r.status === 'fulfilled' && 
            r.value && 
            r.value.success
          );
          
          if (successes.length === 0) {
            const errors = results
              .map(r => r.status === 'fulfilled' ? r.value?.error : r.reason?.message)
              .filter(Boolean);
            throw new Error(`Failed to publish to any relay: ${errors.join(', ')}`);
          }
          
          return { success: true, publishedTo: successes.length };
        },
        
        // Send message
        // Flow: try NIP-07 first if not authenticated, then show modal
        async sendMessage() {
          // If not authenticated, try NIP-07 first, then show modal
          if (!this.isAuthenticated) {
            // Try NIP-07 extension first
            if (this.detectNostrExtension()) {
              console.log('sendMessage: Trying NIP-07...');
              const success = await this.authenticateWithExtension();
              if (!success) {
                this.showAuthModal = true;
                return;
              }
              // Success - continue to send
            } else {
              this.showAuthModal = true;
              return;
            }
          }
          
          if (!this.messageInput.trim() || !this.ndk || !this.ndk.signer) {
            if (!this.ndk || !this.ndk.signer) {
              // If using NIP-07, try to set up signer again
              if (this.usingNip07 || this.useNip7Checkbox) {
                await this.setupSigner();
                if (this.ndk && this.ndk.signer) {
                  // Signer set up, continue
                } else {
                  this.errorMessage = 'Extension signer not available. Please reconnect.';
                  setTimeout(() => { this.errorMessage = ''; }, 3000);
                  return;
                }
              } else {
                this.errorMessage = 'Not connected. Please wait or refresh.';
                setTimeout(() => { this.errorMessage = ''; }, 3000);
                return;
              }
            } else {
              return;
            }
          }
          
          try {
            this.isSending = true;
            
            // Ensure signer is set up (especially for NIP-07)
            if (this.usingNip07 || this.useNip7Checkbox) {
              await this.setupSigner();
              if (!this.ndk.signer) {
                throw new Error('Extension signer not available');
              }
            }
            
            const messageContent = this.messageInput.trim();
            const NDKEvent = window.NDKModule?.NDKEvent;
            if (!NDKEvent) {
              throw new Error('NDKEvent not available');
            }
            
            // Calculate expiration: 30 days from now (Unix timestamp in seconds)
            const expirationTimestamp = Math.floor((Date.now() + (30 * 24 * 60 * 60 * 1000)) / 1000);
            
            const event = new NDKEvent(this.ndk);
            event.kind = 1;
            event.content = messageContent;
            event.tags = [['t', 'radioguaka']];
            
            // Add expiration tag (NIP-40: 30 days from now)
            event.tags.push(['expiration', expirationTimestamp.toString()]);
            
            if (this.currentChannel) {
              event.tags.push(['channel', this.currentChannel]);
            }
            
            // Sign the event - if using NIP-07, this will use the extension's signEvent() method
            await event.sign();
            
            // Get event ID after signing (required for optimistic update)
            const eventId = event.id;
            
            // Ensure we have a valid event ID
            if (!eventId) {
              throw new Error('Failed to generate event ID');
            }
            
            // Ensure messages is an array
            this.ensureMessagesArray();
            
            // Optimistically add message to UI immediately (before publish)
            const optimisticMessage = {
              id: eventId,
              pubkey: this.currentUserPubkey,
              content: messageContent,
              created_at: Math.floor(Date.now() / 1000),
              tags: event.tags,
              optimistic: true // Mark as optimistic
            };
            
            // Insert sorted by timestamp
            const insertIndex = this.messages.findIndex(m => m && m.created_at > optimisticMessage.created_at);
            if (insertIndex === -1) {
              this.messages.push(optimisticMessage);
            } else {
              this.messages.splice(insertIndex, 0, optimisticMessage);
            }
            
            // Force Alpine.js to update
            this.messages = [...this.messages];
            
            // Scroll to bottom to show new message
            this.$nextTick(() => {
              const container = this.$refs.messagesContainer;
              if (container) {
                container.scrollTop = container.scrollHeight;
              }
            });
            
            // Clear input immediately for better UX
            this.messageInput = '';
            
            // Publish to our configured relays only (ignore extension/user relays)
            await this.publishToOurRelays(event);
            
            // Remove optimistic flag once published (message will come back through subscription)
            if (eventId) {
              const messageIndex = this.messages.findIndex(m => m.id === eventId);
              if (messageIndex !== -1 && this.messages[messageIndex].optimistic) {
                this.messages[messageIndex].optimistic = false;
                // Force update
                this.messages = [...this.messages];
              }
            }
            
          } catch (error) {
            console.error('Send error:', error.message);
            this.errorMessage = 'Failed to send message: ' + error.message;
            
            // Remove optimistic message if send failed
            try {
              this.ensureMessagesArray();
              if (event && event.id) {
                this.messages = this.messages.filter(m => m && m.id !== event.id && !m.optimistic);
              }
            } catch (e) {
              // Ignore cleanup errors
            }
            
            setTimeout(() => {
              this.errorMessage = '';
            }, 5000);
          } finally {
            this.isSending = false;
          }
        },
        
        // React to message
        async reactToMessage(eventId, emoji) {
          if (!this.isAuthenticated || !this.ndk || !this.ndk.signer) return;
          
          try {
            const NDKEvent = window.NDKModule?.NDKEvent;
            if (!NDKEvent) return;
            
            const event = new NDKEvent(this.ndk);
            event.kind = 7;
            event.content = emoji;
            event.tags = [['e', eventId]];
            
            await event.sign();
            await this.publishToOurRelays(event);
          } catch (error) {
            console.error('Reaction error:', error);
          }
        },
        
        // Delete message
        async deleteMessage(eventId) {
          if (!this.isAuthenticated || !this.ndk || !this.ndk.signer) return;
          
          try {
            const NDKEvent = window.NDKModule?.NDKEvent;
            if (!NDKEvent) return;
            
            const event = new NDKEvent(this.ndk);
            event.kind = 5;
            event.tags = [['e', eventId]];
            
            await event.sign();
            await this.publishToOurRelays(event);
            
            // Remove from local messages
            this.ensureMessagesArray();
            this.messages = this.messages.filter(m => m && m.id !== eventId);
            
            // Update cache
            this.saveCachedMessages();
          } catch (error) {
            console.error('Delete error:', error);
          }
        },
        
        // Set pubkey and compute npub
        setUserPubkey(pubkey) {
          this.currentUserPubkey = pubkey;
          // Convert to npub using NDK
          if (pubkey && !pubkey.includes('...') && !pubkey.startsWith('npub')) {
            try {
              const NDKUser = window.NDKModule?.NDKUser;
              if (NDKUser) {
                const user = new NDKUser({ pubkey: pubkey });
                this.currentUserNpub = user.npub;
                console.log('Computed npub:', this.currentUserNpub);
              } else {
                console.log('NDKUser not available yet, will retry when NDK loads');
              }
            } catch (e) {
              console.log('Could not convert to npub:', e);
            }
          } else if (pubkey && pubkey.startsWith('npub')) {
            // Already an npub
            this.currentUserNpub = pubkey;
          }
        },
        
        // Set private key and compute nsec
        setUserPrivateKey(privateKey) {
          this.currentUserPrivateKey = privateKey;
          // If already nsec format, use it directly
          if (privateKey && privateKey.startsWith('nsec')) {
            this.currentUserNsec = privateKey;
            console.log('Using nsec directly:', this.currentUserNsec);
          } else if (privateKey && !privateKey.includes('...')) {
            // Convert hex to nsec using NDKPrivateKeySigner
            try {
              const NDKPrivateKeySigner = window.NDKModule?.NDKPrivateKeySigner;
              if (NDKPrivateKeySigner) {
                // Create signer to get user, then get nsec
                const signer = new NDKPrivateKeySigner(privateKey);
                signer.user().then(user => {
                  if (user && user.nsec) {
                    this.currentUserNsec = user.nsec;
                    console.log('Computed nsec:', this.currentUserNsec);
                  }
                }).catch(e => {
                  console.log('Could not get nsec from signer:', e);
                });
              } else {
                console.log('NDKPrivateKeySigner not available yet, will retry when NDK loads');
              }
            } catch (e) {
              console.log('Could not convert to nsec:', e);
            }
          }
        },
        
        // Detect Nostr extensions (nos2x, Alby, etc.)
        detectNostrExtension() {
          // If in iframe, try to access parent window's extension
          if (this.isInIframe) {
            try {
              if (window.parent.nostr && typeof window.parent.nostr.getPublicKey === 'function') {
                // Create a proxy to parent's nostr
                this.parentNostrProxy = window.parent.nostr;
                this.extensionDetected = true;
                // Force Alpine.js to re-render
                this.$nextTick(() => {});
                return true;
              }
              if (window.parent.webln && window.parent.webln.nostr && typeof window.parent.webln.nostr.getPublicKey === 'function') {
                this.parentNostrProxy = window.parent.webln.nostr;
                this.extensionDetected = true;
                // Force Alpine.js to re-render
                this.$nextTick(() => {});
                return true;
              }
            } catch (e) {
              // Cross-origin - can't access parent directly
            }
          }
          
          // Check for standard window.nostr interface (nos2x, etc.)
          if (window.nostr && typeof window.nostr.getPublicKey === 'function') {
            this.extensionDetected = true;
            // Force Alpine.js to re-render
            this.$nextTick(() => {});
            return true;
          }
          
          // Check for Alby's nostr provider
          if (window.webln && window.webln.nostr && typeof window.webln.nostr.getPublicKey === 'function') {
            this.extensionDetected = true;
            // Force Alpine.js to re-render
            this.$nextTick(() => {});
            return true;
          }
          
          this.extensionDetected = false;
          return false;
        },
        
        // Start polling for extension (for extensions that inject async)
        startExtensionPolling() {
          // Clear any existing interval
          if (this.extensionPollInterval) {
            clearInterval(this.extensionPollInterval);
          }
          
          // Try to trigger extension injection by accessing window.nostr
          // Some extensions only inject after first access attempt
          try {
            if (!window.nostr) {
              const test = window.nostr;
            }
          } catch (e) {
            // Ignore
          }
          
          // If in iframe, also try parent window
          if (this.isInIframe) {
            try {
              if (!window.parent.nostr) {
                const test = window.parent.nostr;
              }
            } catch (e) {
              // Ignore
            }
          }
          
          // Check immediately
          this.detectNostrExtension();
          
          // Poll every 500ms for up to 10 seconds
          let attempts = 0;
          const maxAttempts = 20; // 20 * 500ms = 10 seconds
          
          this.extensionPollInterval = setInterval(() => {
            attempts++;
            
            const detected = this.detectNostrExtension();
            if (detected) {
              clearInterval(this.extensionPollInterval);
              this.extensionPollInterval = null;
              // Force Alpine.js to re-render by updating a reactive property
              this.extensionDetected = true;
              this.$nextTick(() => {});
            } else if (attempts >= maxAttempts) {
              clearInterval(this.extensionPollInterval);
              this.extensionPollInterval = null;
            }
          }, 500);
        },
        
        // Stop polling for extension
        stopExtensionPolling() {
          if (this.extensionPollInterval) {
            clearInterval(this.extensionPollInterval);
            this.extensionPollInterval = null;
          }
        },
        
        // Authenticate with extension (NIP-07)
        // IMPORTANT: With NIP-07, the website NEVER needs access to the private key.
        // The extension securely stores the private key and only provides:
        // - getPublicKey() - returns the public key
        // - signEvent(event) - signs events using the extension's private key
        // The private key never leaves the extension's secure storage.
        async authenticateWithExtension() {
          try {
            // If we have a parent proxy (from iframe detection), use it
            let nostrProvider = this.parentNostrProxy;
            
            // Try standard window.nostr first
            if (!nostrProvider) {
              nostrProvider = window.nostr;
            }
            
            // Fallback to Alby's nostr provider
            if (!nostrProvider && window.webln && window.webln.nostr) {
              nostrProvider = window.webln.nostr;
            }
            
            // If in iframe and no provider yet, try parent window
            if (!nostrProvider && this.isInIframe) {
              try {
                if (window.parent.nostr && typeof window.parent.nostr.getPublicKey === 'function') {
                  nostrProvider = window.parent.nostr;
                  this.parentNostrProxy = nostrProvider;
                } else if (window.parent.webln && window.parent.webln.nostr && typeof window.parent.webln.nostr.getPublicKey === 'function') {
                  nostrProvider = window.parent.webln.nostr;
                  this.parentNostrProxy = nostrProvider;
                }
              } catch (e) {
                this.errorMessage = 'Cannot access extension in parent window: ' + e.message;
                setTimeout(() => { this.errorMessage = ''; }, 5000);
                this.useNip7Checkbox = false;
                return false;
              }
            }
            
            if (!nostrProvider) {
              this.useNip7Checkbox = false; // Uncheck if extension not available
              this.errorMessage = 'No NIP-07 extension found';
              setTimeout(() => { this.errorMessage = ''; }, 3000);
              return false;
            }
            
            // Check if getPublicKey method exists
            if (typeof nostrProvider.getPublicKey !== 'function') {
              this.useNip7Checkbox = false; // Uncheck if extension not working
              this.errorMessage = 'Extension found but getPublicKey is not a function';
              setTimeout(() => { this.errorMessage = ''; }, 3000);
              return false;
            }
            
            // Get public key from extension
            let pubkey;
            try {
              pubkey = await nostrProvider.getPublicKey();
            } catch (e) {
              this.errorMessage = 'Error getting public key: ' + e.message;
              setTimeout(() => { this.errorMessage = ''; }, 5000);
              this.useNip7Checkbox = false;
              return false;
            }
            
            if (!pubkey) {
              this.useNip7Checkbox = false; // Uncheck if auth failed
              this.errorMessage = 'No public key returned from extension';
              setTimeout(() => { this.errorMessage = ''; }, 3000);
              return false;
            }
            
            this.setUserPubkey(pubkey);
            this.isAuthenticated = true;
            this.usingNip07 = true; // Mark that we're using NIP-07 (no nsec available)
            this.currentUserPrivateKey = null; // Clear any stored private key
            this.currentUserNsec = null; // No nsec with NIP-07
            this.useNip7Checkbox = true; // Keep checkbox checked
            this.showAuthModal = false;
            
            // Wait for NDK to be ready before setting up signer
            if (!this.ndk) {
              // Wait for NDK to initialize
              await new Promise((resolve) => {
                if (this.ndk) {
                  resolve();
                } else {
                  const checkNDK = setInterval(() => {
                    if (this.ndk) {
                      clearInterval(checkNDK);
                      resolve();
                    }
                  }, 100);
                  // Timeout after 5 seconds
                  setTimeout(() => {
                    clearInterval(checkNDK);
                    resolve(); // Continue anyway
                  }, 5000);
                }
              });
            }
            
            // Set up signer with extension
            // The extension's signer will use nostrProvider.signEvent() internally
            // The private key remains in the extension and is never exposed to the website
            // Store the provider we found for use in setupSigner
            this.detectedNostrProvider = nostrProvider;
            await this.setupSigner();
            
            // Fetch user's profile to get NIP-05 and other info
            this.fetchCurrentUserProfile();
            
            // Save pubkey to localStorage (but don't save private key - extension handles that)
            // With NIP-07, we only need the public key - the extension manages the private key securely
            localStorage.setItem('radio_guaka_chat_pubkey', pubkey);
            // Clear any saved private key since we're using extension
            // This ensures we don't accidentally use a stored key when extension is available
            localStorage.removeItem('radio_guaka_chat_private_key');
            // Mark that we're using NIP-07
            localStorage.setItem('radio_guaka_chat_using_nip07', 'true');
            
            return true;
            
          } catch (error) {
            this.useNip7Checkbox = false; // Uncheck on error
            this.errorMessage = 'Authentication error: ' + (error.message || error.toString());
            setTimeout(() => { this.errorMessage = ''; }, 5000);
            return false; // Return false instead of throwing
          }
        },
        
        // Authenticate with key (nsec only)
        async authenticateWithKey() {
          try {
            if (!this.manualKey.trim()) {
              this.errorMessage = 'Please enter an nsec key';
              setTimeout(() => { this.errorMessage = ''; }, 3000);
              return;
            }
            
            const key = this.manualKey.trim();
            this.errorMessage = ''; // Clear previous errors
            
            // Only accept nsec
            if (!key.startsWith('nsec')) {
              this.errorMessage = 'Only nsec private keys are accepted. Please enter an nsec1... key.';
              setTimeout(() => {
                this.errorMessage = '';
              }, 6000);
              return;
            }
            
            // Private key - use NDK to decode
            try {
              const NDKUser = window.NDKModule?.NDKUser;
              if (NDKUser) {
                const user = NDKUser.fromNsec(key);
                this.setUserPrivateKey(key);
                this.setUserPubkey(user.pubkey);
              } else {
                // Fallback: store as-is
                this.setUserPrivateKey(key);
                // Try to get pubkey from signer after setup
                this.currentUserPubkey = 'loading...';
              }
              
              this.isAuthenticated = true;
              this.showAuthModal = false;
              this.showManualAuth = false;
              
              this.usingNip07 = false; // Not using NIP-07 when importing key
              this.useNip7Checkbox = false; // Uncheck NIP-07 when importing key
              localStorage.setItem('radio_guaka_chat_private_key', key);
              localStorage.removeItem('radio_guaka_chat_using_nip07');
              if (this.currentUserPubkey && this.currentUserPubkey !== 'loading...') {
                localStorage.setItem('radio_guaka_chat_pubkey', this.currentUserPubkey);
              }
              
              await this.setupSigner();
              
              // Update pubkey after signer is set up if needed
              if (this.currentUserPubkey === 'loading...' && this.ndk && this.ndk.signer) {
                try {
                  const user = await this.ndk.signer.user();
                  if (user && user.pubkey) {
                    this.setUserPubkey(user.pubkey);
                    localStorage.setItem('radio_guaka_chat_pubkey', user.pubkey);
                  }
                } catch (e) {
                  console.error('Error getting pubkey from signer:', e);
                }
              }
              
              // Fetch user's profile to get NIP-05
              this.fetchCurrentUserProfile();
            } catch (e) {
              this.errorMessage = 'Invalid nsec format. Please check your key and try again.';
              setTimeout(() => {
                this.errorMessage = '';
              }, 6000);
            }
            
          } catch (error) {
            console.error('Key auth error:', error);
            this.errorMessage = 'Authentication failed: ' + error.message;
            setTimeout(() => {
              this.errorMessage = '';
            }, 6000);
          } finally {
            // Clear the manual key input after processing
            if (this.isAuthenticated) {
              this.manualKey = '';
              this.showManualAuth = false;
            }
          }
        },
        
        // Generate new key
        async generateNewKey() {
          try {
            this.errorMessage = ''; // Clear any previous errors
            this.usingNip07 = false; // Not using NIP-07 when generating new key
            this.useNip7Checkbox = false; // Uncheck NIP-07 when generating new key
            
            // Use NDK to generate a keypair
            if (window.NDKModule && window.NDKModule.generatePrivateKey) {
              const privateKey = window.NDKModule.generatePrivateKey();
              const NDKPrivateKeySigner = window.NDKModule.NDKPrivateKeySigner;
              
              if (NDKPrivateKeySigner) {
                try {
                  // Use signer to get user and pubkey
                  const signer = new NDKPrivateKeySigner(privateKey);
                  const user = await signer.user();
                  if (user && user.pubkey) {
                    this.setUserPrivateKey(privateKey);
                    this.setUserPubkey(user.pubkey);
                    // Try to get nsec if available
                    if (user.nsec) {
                      this.currentUserNsec = user.nsec;
                    }
                  } else {
                    this.setUserPrivateKey(privateKey);
                    this.currentUserPubkey = 'generating...';
                  }
                } catch (e) {
                  // If signer fails, just store the key
                  this.setUserPrivateKey(privateKey);
                  this.currentUserPubkey = 'generating...';
                }
              } else {
                // Fallback: generate hex key and convert
                this.setUserPrivateKey(privateKey);
                this.currentUserPubkey = 'generating...';
              }
            } else {
              // Fallback: generate random hex using Web Crypto API
              const bytes = new Uint8Array(32);
              crypto.getRandomValues(bytes);
              const hex = Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
              this.setUserPrivateKey(hex);
              this.currentUserPubkey = 'generating...';
            }
            
            this.isAuthenticated = true;
            this.showAuthModal = false;
            
            // Save to localStorage
            localStorage.setItem('radio_guaka_chat_private_key', this.currentUserPrivateKey);
            localStorage.removeItem('radio_guaka_chat_using_nip07');
            if (this.currentUserPubkey && this.currentUserPubkey !== 'generating...') {
              localStorage.setItem('radio_guaka_chat_pubkey', this.currentUserPubkey);
            }
            
            await this.setupSigner();
            
            // Update pubkey after signer is set up
            if (this.currentUserPubkey === 'generating...' && this.ndk && this.ndk.signer) {
              try {
                const user = await this.ndk.signer.user();
                if (user && user.pubkey) {
                  this.currentUserPubkey = user.pubkey;
                  localStorage.setItem('radio_guaka_chat_pubkey', user.pubkey);
                }
              } catch (e) {
                console.error('Error getting pubkey from signer:', e);
                this.errorMessage = 'Key generated but failed to get public key. You may need to reconnect.';
                setTimeout(() => { this.errorMessage = ''; }, 5000);
              }
            }
            
          } catch (error) {
            console.error('Key generation error:', error.message);
            this.errorMessage = 'Failed to generate key: ' + error.message;
            setTimeout(() => {
              this.errorMessage = '';
            }, 6000);
          }
        },
        
        // Delete all keys
        deleteKeys() {
          this.currentUserPrivateKey = null;
          this.currentUserNsec = null;
          this.currentUserPubkey = null;
          this.currentUserNpub = null;
          this.currentUserNip05 = null;
          this.usingNip07 = false;
          this.useNip7Checkbox = false;
          this.isAuthenticated = false;
          this.manualKey = '';
          this.showPrivateKey = false;

          // Clear from localStorage
          localStorage.removeItem('radio_guaka_chat_private_key');
          localStorage.removeItem('radio_guaka_chat_pubkey');
          localStorage.removeItem('radio_guaka_chat_using_nip07');

          // Clear signer
          if (this.ndk) {
            this.ndk.signer = null;
          }
        },
        
        // Create NIP-07 signer adapter (implements NDK signer interface)
        createNip07Signer(nostrProvider, pubkey, ndkInstance) {
          const NDKUser = window.NDKModule?.NDKUser;
          if (!NDKUser) {
            throw new Error('NDKUser not available');
          }
          
          // Create a signer adapter that implements NDK's signer interface
          // IMPORTANT: We do NOT expose getRelays() to prevent NDK from using extension relays
          const signer = {
            _pubkey: pubkey,
            _nostrProvider: nostrProvider,
            
            // NDK expects signer.user() to return a Promise<NDKUser>
            async user() {
              const user = new NDKUser({ pubkey: pubkey });
              if (ndkInstance) {
                user.ndk = ndkInstance;
              }
              return user;
            },
            
            // NDK calls sign() on the signer, passing the NDKEvent
            // NDK expects sign() to update the event's sig and return the signature string
            async sign(event) {
              // Convert NDKEvent to plain object for extension
              const plainEvent = {
                kind: event.kind,
                created_at: event.created_at || Math.floor(Date.now() / 1000),
                tags: event.tags || [],
                content: event.content || '',
                pubkey: pubkey
              };

              // Use extension's signEvent method
              const signedEvent = await nostrProvider.signEvent(plainEvent);

              // Update the NDKEvent with signed data
              event.id = signedEvent.id;
              event.sig = signedEvent.sig;
              event.pubkey = signedEvent.pubkey;
              
              // NDK expects sign() to return the signature string
              return signedEvent.sig;
            },
            
            // NOTE: We intentionally do NOT expose getRelays() here
            // This prevents NDK from using extension/user relays
            // Return empty array if NDK tries to call it
            getRelays: async () => {
              // Return empty array to prevent NDK from using extension relays
              return [];
            }
          };
          
          return signer;
        },
        
        // Setup signer
        async setupSigner() {
          try {
            if (!this.ndk) return;
            
            // If using NIP-07, prioritize extension signer
            if (this.usingNip07 || this.useNip7Checkbox) {
              // Try to use extension signer
              // Use the provider we detected (could be from parent window if in iframe)
              let nostrProvider = this.detectedNostrProvider || this.parentNostrProxy;
              
              if (!nostrProvider) {
                nostrProvider = window.nostr;
              }
              if (!nostrProvider && window.webln && window.webln.nostr) {
                nostrProvider = window.webln.nostr;
              }
              // If in iframe, also try parent
              if (!nostrProvider && this.isInIframe) {
                try {
                  if (window.parent.nostr && typeof window.parent.nostr.getPublicKey === 'function') {
                    nostrProvider = window.parent.nostr;
                    this.parentNostrProxy = nostrProvider;
                  } else if (window.parent.webln && window.parent.webln.nostr && typeof window.parent.webln.nostr.getPublicKey === 'function') {
                    nostrProvider = window.parent.webln.nostr;
                    this.parentNostrProxy = nostrProvider;
                  }
                } catch (e) {
                  // Cross-origin, can't access
                }
              }
              
              if (nostrProvider && this.currentUserPubkey) {
                // Create NIP-07 signer adapter that implements NDK's signer interface
                const signer = this.createNip07Signer(nostrProvider, this.currentUserPubkey, this.ndk);
                this.ndk.signer = signer;
                this.detectedNostrProvider = nostrProvider; // Store for future use
                return; // Done - extension signer is set
              }
            }
            
            // Try to use extension signer (even if not explicitly using NIP-07)
            // Use the provider we detected (could be from parent window if in iframe)
            let nostrProvider = this.detectedNostrProvider || this.parentNostrProxy;
            
            if (!nostrProvider) {
              nostrProvider = window.nostr;
            }
            if (!nostrProvider && window.webln && window.webln.nostr) {
              nostrProvider = window.webln.nostr;
            }
            // If in iframe, also try parent
            if (!nostrProvider && this.isInIframe) {
              try {
                if (window.parent.nostr && typeof window.parent.nostr.getPublicKey === 'function') {
                  nostrProvider = window.parent.nostr;
                  this.parentNostrProxy = nostrProvider;
                } else if (window.parent.webln && window.parent.webln.nostr && typeof window.parent.webln.nostr.getPublicKey === 'function') {
                  nostrProvider = window.parent.webln.nostr;
                  this.parentNostrProxy = nostrProvider;
                }
              } catch (e) {
                // Cross-origin, can't access
              }
            }
            
            if (nostrProvider && this.currentUserPubkey) {
              // Create NIP-07 signer adapter
              const signer = this.createNip07Signer(nostrProvider, this.currentUserPubkey, this.ndk);
              this.ndk.signer = signer;
              this.detectedNostrProvider = nostrProvider; // Store for future use
            } else if (this.currentUserPrivateKey) {
              // Use private key signer
              try {
                const NDKPrivateKeySigner = window.NDKModule.NDKPrivateKeySigner;
                if (NDKPrivateKeySigner) {
                  this.ndk.signer = new NDKPrivateKeySigner(this.currentUserPrivateKey);
                } else {
                  // Fallback: try to use private key directly
                  // NDK should handle nsec format
                  const NDKUser = window.NDKModule.NDKUser;
                  if (NDKUser) {
                    // Create user from private key
                    const user = NDKUser.fromNsec(this.currentUserPrivateKey);
                    if (user) {
                      user.ndk = this.ndk;
                    }
                  }
                }
              } catch (e) {
                console.error('Error setting up private key signer:', e);
              }
            }
          } catch (error) {
            console.error('Signer setup error:', error);
          }
        },
        
        // Fetch current user's profile to get NIP-05 and other info
        async fetchCurrentUserProfile() {
          try {
            if (!this.ndk || !this.currentUserPubkey) return;
            
            // Check if we already have their profile cached
            if (this.userProfiles[this.currentUserPubkey]?.nip05) {
              this.currentUserNip05 = this.userProfiles[this.currentUserPubkey].nip05;
              return;
            }
            
            const filter = {
              kinds: [0], // Profile metadata
              authors: [this.currentUserPubkey],
              limit: 1
            };
            
            const events = await this.ndk.fetchEvents(filter);
            
            if (events && events.size > 0) {
              for (const event of events) {
                this.handleProfileEvent(event);
              }
            }
          } catch (error) {
            console.error('Error fetching user profile:', error);
          }
        },
        
        // Fetch past messages directly (fallback method)
        async fetchPastMessages() {
          try {
            if (!this.ndk) return;
            
            const filter = {
              kinds: [1],
              '#t': ['radioguaka'],
              limit: 100
            };
            
            // Use fetchEvents for a one-time fetch
            const events = await this.ndk.fetchEvents(filter);
            
            if (events && events.size > 0) {
              for (const event of events) {
                this.handleMessageEvent(event);
              }
            }
            
            this.isLoading = false;
          } catch (error) {
            console.error('Error fetching past messages:', error);
            this.isLoading = false;
          }
        },
        
        // Load cached messages from localStorage
        loadCachedMessages() {
          try {
            // Ensure messages is initialized as array
            this.ensureMessagesArray();
            
            const cached = localStorage.getItem('radio_guaka_chat_messages');
            if (cached) {
              const messages = JSON.parse(cached);
              if (Array.isArray(messages) && messages.length > 0) {
                // Filter out any messages without valid IDs
                const validMessages = messages.filter(m => m && m.id);
                this.messages = validMessages;
                // Deduplicate after loading
                this.deduplicateMessages();
                
                // Scroll to bottom after loading cached messages
                this.$nextTick(() => {
                  const container = this.$refs.messagesContainer;
                  if (container) {
                    container.scrollTop = container.scrollHeight;
                  }
                });
              }
            }
          } catch (e) {
            console.error('Error loading cached messages:', e);
            // Clear corrupted cache and ensure messages is an array
            localStorage.removeItem('radio_guaka_chat_messages');
            this.ensureMessagesArray();
          }
        },
        
        // Save messages to localStorage cache
        saveCachedMessages() {
          try {
            // Ensure messages is an array
            this.ensureMessagesArray();
            
            // Only save the last 200 messages with valid IDs to avoid storage limits
            const toSave = this.messages
              .filter(m => m && m.id) // Only messages with valid IDs
              .slice(-200)
              .map(m => ({
                id: m.id,
                pubkey: m.pubkey,
                content: m.content,
                created_at: m.created_at,
                tags: m.tags
              }));
            localStorage.setItem('radio_guaka_chat_messages', JSON.stringify(toSave));
          } catch (e) {
            console.error('Error saving cached messages:', e);
          }
        },
        
        // Mark all relays as connected (called when we receive events)
        markRelaysConnected() {
          for (const relayUrl of this.relays) {
            if (this.relayStatus[relayUrl]?.status !== 'connected') {
              this.relayStatus[relayUrl] = { status: 'connected' };
            }
          }
        },
        
        // Update relay status by checking actual connection state
        updateRelayStatus() {
          try {
            if (!this.ndk || !this.ndk.pool) return;
            
            // Check each configured relay's actual status
            for (const relayUrl of this.relays) {
              // Try different ways to get relay status from NDK pool
              let relay = null;
              
              // NDK v2.x: pool.relays is a Map
              if (this.ndk.pool.relays && this.ndk.pool.relays.get) {
                relay = this.ndk.pool.relays.get(relayUrl);
              }
              
              // Try to find relay in pool by URL
              if (!relay && this.ndk.pool.relays) {
                for (const [url, r] of this.ndk.pool.relays) {
                  if (url === relayUrl || r?.url === relayUrl) {
                    relay = r;
                    break;
                  }
                }
              }
              
              if (relay) {
                // Check relay's connection status
                // NDK relay status can be: 'connecting', 'connected', 'disconnected', etc.
                const status = relay.status || relay.connectionStatus || relay.readyState;
                
                if (status === 'connected' || status === 1 || status === WebSocket.OPEN) {
                  this.relayStatus[relayUrl] = { status: 'connected' };
                } else if (status === 'connecting' || status === 0 || status === WebSocket.CONNECTING) {
                  this.relayStatus[relayUrl] = { status: 'connecting' };
                } else {
                  this.relayStatus[relayUrl] = { status: 'disconnected' };
                }
              }
            }
            
          } catch (e) {
            // Ignore relay status errors
          }
        },
        
        // Load keys from storage
        async loadKeysFromStorage() {
          try {
            const privateKey = localStorage.getItem('radio_guaka_chat_private_key');
            const pubkey = localStorage.getItem('radio_guaka_chat_pubkey');
            const usingNip07 = localStorage.getItem('radio_guaka_chat_using_nip07') === 'true';
            
            if (usingNip07 && pubkey) {
              // We were using NIP-07 - restore that state
              this.usingNip07 = true;
              this.useNip7Checkbox = true; // Restore checkbox state
              this.currentUserPrivateKey = null;
              this.currentUserNsec = null;
              this.setUserPubkey(pubkey);
              this.isAuthenticated = true;
              // Try to reconnect with extension
              if (this.detectNostrExtension()) {
                await this.authenticateWithExtension();
              }
            } else if (privateKey) {
              this.useNip7Checkbox = false; // Not using NIP-07
              this.usingNip07 = false;
              this.setUserPrivateKey(privateKey);
              this.isAuthenticated = true;
              
              // If we have pubkey, use it; otherwise we'll get it from signer
              if (pubkey) {
                this.setUserPubkey(pubkey);
              }
              
              // Set up signer if NDK is ready
              if (this.ndk) {
                await this.setupSigner();
                // Update pubkey from signer if available
                if (this.ndk && this.ndk.signer) {
                  try {
                    const user = await this.ndk.signer.user();
                    if (user && user.pubkey) {
                      this.setUserPubkey(user.pubkey);
                      localStorage.setItem('radio_guaka_chat_pubkey', user.pubkey);
                    }
                  } catch (e) {
                    // Could not get pubkey from signer
                  }
                }
                // Fetch user's profile to get NIP-05
                this.fetchCurrentUserProfile();
              }
            } else if (pubkey) {
              this.usingNip07 = false;
              this.useNip7Checkbox = false;
              this.setUserPubkey(pubkey);
              this.isAuthenticated = false; // Read-only
            } else {
              this.useNip7Checkbox = false; // Default to unchecked
            }
          } catch (e) {
            console.error('Error loading keys:', e);
          }
        },
        
      };
    }
  </script>
</body>
</html>

